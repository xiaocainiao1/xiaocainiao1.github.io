<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-git简单命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/17/git%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/" class="article-date">
  <time datetime="2021-01-17T15:11:31.644Z" itemprop="datePublished">2021-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="git简单命令"><a href="#git简单命令" class="headerlink" title="git简单命令"></a>git简单命令</h1><p><strong>上传</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git init    初始化仓库</span><br><span class="line"></span><br><span class="line">git add .   提交当前目录到缓存</span><br><span class="line"></span><br><span class="line">git commit  -m &quot;my first commit&quot;  把缓存提交到本地仓库</span><br><span class="line"></span><br><span class="line">git  remote add origin    添加远程仓库</span><br><span class="line"></span><br><span class="line">git push -u origin master 推送到远程仓库   --注意按提示输入用户名、密码</span><br></pre></td></tr></table></figure>

<p>备注：如果第一次使用Git,<strong>需配置全局的参数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name “你的用户名”</span><br><span class="line">git config --global user.email “你的邮箱”</span><br></pre></td></tr></table></figure>

<p><strong>下载</strong></p>
<p> git clone <a target="_blank" rel="noopener" href="http://www.kernel.org/pub/scm/git/git.git">http://www.kernel.org/pub/scm/git/git.git</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/17/git%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/" data-id="clh04c6dk000co4rgfddreht0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Hadoop完全分布式集群搭建（Hadoop3.3.0）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/15/Hadoop%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%EF%BC%88Hadoop3.3.0%EF%BC%89/" class="article-date">
  <time datetime="2021-01-15T01:20:28.265Z" itemprop="datePublished">2021-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Hadoop完全分布式集群搭建（Hadoop3-3-0）"><a href="#Hadoop完全分布式集群搭建（Hadoop3-3-0）" class="headerlink" title="Hadoop完全分布式集群搭建（Hadoop3.3.0）"></a>Hadoop完全分布式集群搭建（Hadoop3.3.0）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>最近在接触大数据相关的项目，项目需求：Hadoop3.3.0 数据库 + CentOs7 环境部署，本着自以为很简单的心态开始部署，结果由于网上教程过于老旧，再加上各位大佬发的帖子基本一知半解，导致部署过程中查找资料不下20篇，踩过的坑不计其数，本着技术共享的心态特将此次实际部署过程完整的发布出来，以便大家少走弯路，保证如果细心看完之后能够通过本篇文章一站式部署成功，不用在东奔西走去搜集各种资料和踩坑。</p>
<p>想要完全掌握一个新架构，就需要知其然再知其所以然，这样以便日后进行修改和维护，所以本文将从零开始直至完全部署完毕，细节和重点将给各位画出来。</p>
<p><strong>一、Hadoop数据库是什么？</strong></p>
<p>Hadoop数据库是一个分布式框架数据库，属于非关系型数据库（更详细的请自行科普）</p>
<p><strong>二、Hadoop分布式数据库和关系型数据库区别</strong></p>
<p><strong>1、关系型数据库特点：</strong>结构化存储，一对多的层次型特性，数据类型基于字符串。表现形式类似于Execel表，数据以每个Excel表的样式存储在数据库中。</p>
<p><strong>2、非关系型数据库特点：</strong></p>
<p>非关系型数据库通常以字典数据类型存储，没有对应关系表。Hadoop数据库利用name node字段记录文件被分散存储的属性值，利用date node字段存储文件分散路径，表现形式类似于Windows系统注册表和系统文件的对应关系。</p>
<p><strong>三、Hadoop特性</strong></p>
<p>Hadoop就是为了解决海量数据的存储与运算问题，它所存储的数据类型是消息和文件，消息用来记录文件的存放属性，文件会被分布存储到各个Hadoop文件系统中，并且在整个群集中形成多个副本。</p>
<p>Hadoop数据库分为多个功能，这些功能在一个安装包中，每台服务器安装其中一个功能，进行多台安装。</p>
<p>通常用一台name node，用来存放文件属性，多台data node 用来存放文件块。 Hadoop分布式数据库读写原理。</p>
<p><strong>四、Hadoop运行环境</strong></p>
<p>Linux系统，Java JDK8以上开发环境组件。</p>
<p><strong>五、Hadoop分布式数据库读写原理</strong></p>
<p>1、由接口收发数据</p>
<p>2、由分布式调度平台将任务分为存储分布式和运算分布式进行任务下发。</p>
<p>3、存储任务：目标数据会分分割成若干个小份，以文件的形式散落在各个Hadoop分布式文件系统中，并且每个小块会在整个群集中存储多个副本，当需要取出时进行文件聚合。</p>
<p>4、运算任务: 一个任务会被分发到多台服务器中并行计算，快速计算出结果。</p>
<p><strong>六、Hadoop基本架构</strong></p>
<p>name node字段: 用来记录消息，也就是 分布式文件块大小，分割成几个块等。</p>
<p>data node: 用来存储文件路径和文件。</p>
<p><img src="https://pics5.baidu.com/feed/dbb44aed2e738bd44c23a071320cdfd1267ff9fb.jpeg?token=d42b09b4c2f344c0acd225b0e39698d6" alt="img"></p>
<p><strong>七、Hadoop交互方式介绍</strong></p>
<p>Hadoop交互分为命令行模式和交互式界面：</p>
<p><strong>1、命令行模式</strong>: Hadoop通过Linux终端方式连接，操作命令和Linux系统命令相差 不多。</p>
<p><strong>2、界面交互</strong>: 可以通过web浏览器方式访问Hadoop节点服务器。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>1、准备工作：</p>
<p>（1）准备Linux服务器：虚拟机或物理机都行，用来搭建Hadoop分布式数据库。</p>
<p>（2）下载JDK 8 。</p>
<p>（3）下载 Hadoop3.3.0 for Linux 安装包。</p>
<p>（4）推荐到官网下载，或自行搜索下载，这里推荐<a target="_blank" rel="noopener" href="http://mirrors.hust.edu.cn/apache/hadoop/common/hadoop-3.3.0/">华中科技大学镜像</a>下载</p>
<h2 id="开始部署Hadoop分布式数据库"><a href="#开始部署Hadoop分布式数据库" class="headerlink" title="开始部署Hadoop分布式数据库"></a>开始部署Hadoop分布式数据库</h2><h4 id="1、修改MAC地址（非虚拟机无需）"><a href="#1、修改MAC地址（非虚拟机无需）" class="headerlink" title="1、修改MAC地址（非虚拟机无需）"></a><strong>1、修改MAC地址</strong>（非虚拟机无需）</h4><p>克隆的虚拟机，为避免Mac地址冲突，需要关闭虚拟机，重新生成MAC地址。</p>
<p><img src="https://pics1.baidu.com/feed/30adcbef76094b363787dc41334b24de8c109d90.jpeg?token=0b1ba1ab25026e58377f2effe596a432" alt="img">客户端连接</p>
<h4 id="2、修改主机名："><a href="#2、修改主机名：" class="headerlink" title="2、修改主机名："></a><strong>2、修改主机名：</strong></h4><p>例如：hdp01 、hdp02、hdp0…</p>
<p>(1) 修改显示主机名：hostnamectl set-hostname hdp01</p>
<p>(2) 修改网络主机名：</p>
<p>vi /etc/sysconfig/network ~ 编辑配置文件</p>
<p>HOSTNAME=hdp01 ~ 将网络主机名改为hdp01</p>
<h4 id="3、修改静态IP（仅本地物理或虚拟机需要改）："><a href="#3、修改静态IP（仅本地物理或虚拟机需要改）：" class="headerlink" title="3、修改静态IP（仅本地物理或虚拟机需要改）："></a><strong>3、修改静态IP（仅本地物理或虚拟机需要改）：</strong></h4><p>将服务器修改成静态IP：如果是云服务器不需要改ip地址，否则会断网。</p>
<p>（1）编辑配置文件：vi /etc/sysconfig/network-scripts/ifcfg-ens33 添加下面的 代码。（vi编辑器 i 进入编辑模式、ESC退出编辑模式、:wq 保存退出）</p>
<p>IPADDR=192.168.1.10</p>
<p>GATEWAY=192.168.1.1</p>
<p>NETMASK=255.255.255.0</p>
<p>DNS1=114.114.114.114</p>
<p><img src="https://pics7.baidu.com/feed/562c11dfa9ec8a13932d2de36484c988a0ecc009.jpeg?token=6f69b8554f324027bce5c950d1377d49" alt="img"></p>
<p>（2）重启网络：service network restart</p>
<h4 id="4、增加域名映射："><a href="#4、增加域名映射：" class="headerlink" title="4、增加域名映射："></a><strong>4、增加域名映射：</strong></h4><p>在没有域的情况下，主机之间能通过主机名来互相访问，这就是修改hosts文件的作用，编辑hosts文件：vi /etc/hosts 输入要映射的主机名和IP地址（IP地址改成你当前主机的IP）。</p>
<p>192.168.1.11 hdp01</p>
<p>192.168.1.12 hdp02</p>
<h4 id="5、安装scp和-yum-所有主机"><a href="#5、安装scp和-yum-所有主机" class="headerlink" title="5、安装scp和 yum(所有主机)"></a><strong>5、安装scp和 yum(所有主机)</strong></h4><p>（1）先安装scp：如果能正常装上，yum update 就不用做。</p>
<p>scp工具：Linux下文件拷贝的基本工具，建议安装，可以使用命令安装。</p>
<p>yum install openssh-clients -y</p>
<p>（2）安装yum工具：后面用来安装系统组件、其他软件的必备工具，可以使用命令 安装或本地安装两种方式， yum update 。</p>
<h4 id="6、重点！卸载系统自带JAVA（每台主机）"><a href="#6、重点！卸载系统自带JAVA（每台主机）" class="headerlink" title="6、重点！卸载系统自带JAVA（每台主机）"></a><strong>6、重点！卸载系统自带JAVA（每台主机）</strong></h4><p>因系统自带JAVA版本可能比较老，而此时又新增高版本JAVA，可能在下面的配置过程中产生冲突，需提前检查，如果有则卸载。</p>
<p>（1）查看当前已安装的JAVA：rpm -qa|grep jdk</p>
<p>（2）使用rpm -e –nodeps命令将这些查询出来的全卸载掉：</p>
<p>rpm -e –nodeps java-1.8.0-openjdk-1.8.0.242.b08-1.el7.x86_64</p>
<p>（3）查看当前jdk版本：java -version</p>
<p>（4）刷新环境变量：source /etc/profile</p>
<h4 id="7、安装JDK、配置JAVA环境变量（每台主机）"><a href="#7、安装JDK、配置JAVA环境变量（每台主机）" class="headerlink" title="7、安装JDK、配置JAVA环境变量（每台主机）"></a><strong>7、安装JDK、配置JAVA环境变量（每台主机）</strong></h4><p>以上都配置好之后，就可以通过远程方式，拿终端连接Linux主机，一切都在终端上完成，推荐使用 SecureCRT 工具。</p>
<p>（1）上传JDK包到Linux：先在根路径下创建一个Hadoop的目录，用来存放java包和Hadoop包。</p>
<p>mkdir /hadoop3</p>
<p>（2）上传JDK包：将JDK压缩包上传到/Hadoop目录下备用）。</p>
<p>cd /hadoop3</p>
<p>put D:\jdk-14.0.8_linux-x64_bin.tar.gz</p>
<p><img src="https://pics3.baidu.com/feed/2fdda3cc7cd98d10364e6276b1b8e0097aec9069.png?token=8b722d42b94d26ab4195441f617ba88f" alt="img"></p>
<p>（3）配置JAVA环境变量</p>
<p>解压JDK包到当前目录：tar -zxvf D:\jdk-14.0.2_linux-x64_bin.tar.gz</p>
<p><img src="https://pics6.baidu.com/feed/11385343fbf2b2113c327a6e59073d3f0cd78e05.jpeg?token=f0dbdf43bebc5f94f001a2b63f0b6b53" alt="img"></p>
<p>编辑环境变量配置文件：vi /etc/profile</p>
<p>export JAVA_HOME=/hadoop/jdk-14.0.2 （你的解压完jdk后的那个主目录）</p>
<p>拼接环境变量：export PATH=$PATH**:**$JAVA_HOME/bin</p>
<p><img src="https://pics0.baidu.com/feed/b8014a90f603738d3750448f209ce856f919ec90.jpeg?token=028c34d8aad1d2be224af7f1a11f7825" alt="img">截图仅供参考实际目录以你当前jdk为准</p>
<p>测试JAVA环境变量：配置完环境变量后测试，保证配置是正确的，再向下进行：直接输入 JAVA。</p>
<p><img src="https://pics2.baidu.com/feed/14ce36d3d539b60076771dba79d76d2dc75cb794.jpeg?token=4a39ad23d452c64790c90224fc2056ce" alt="img"></p>
<h4 id="8、配置免密登陆"><a href="#8、配置免密登陆" class="headerlink" title="8、配置免密登陆 !"></a><strong>8、配置免密登陆 !</strong></h4><p>配置从A主机到其他所有主机的免密登陆：</p>
<p>（1）在A主机生成密钥：</p>
<p>。使用root用户登陆系统</p>
<p>。 生成密钥：ssh-keygen (生成的密钥文件在/root/.ssh下 id_rsa 、id_rsa.pub)</p>
<p>（2）配置自己对自己的免密登陆：ssh-copy-id hdp01 （hdp01就是你当前第一台的主机名）</p>
<p>（3）将密钥文件拷贝到其他所有主机上：ssh-copy-id hdp02 回车</p>
<p>。。。 根据提示输入 yes ，根据提示输入对方主机的 root 密码，敲回车。</p>
<p>成功的提示：Now try logging into the machine, with “ssh ‘hdp02’ “,</p>
<p>and check in: .ssh/authorized_keys</p>
<p>（4）如果还需要配置其他免密登陆的主机继续：ssh-copy-id hdp03 ….</p>
<p>（5）配置完免密登陆后执行一次：ssh hdp01 、ssh hdp02</p>
<h4 id="9、关闭防火墙"><a href="#9、关闭防火墙" class="headerlink" title="9、关闭防火墙"></a><strong>9、关闭防火墙</strong></h4><p>搭建的过程中先将防火墙关闭，或者放行端口：</p>
<p>关闭防火墙命令：systemctl stop firewalld.service</p>
<p>开启防火墙命令：systemctl start firewalld.service</p>
<h4 id="10、hadoop3-3-0安装搭建"><a href="#10、hadoop3-3-0安装搭建" class="headerlink" title="10、hadoop3.3.0安装搭建"></a>10、hadoop3.3.0安装搭建</h4><p>这里我下载hadoop的版本是3.3.0，下载地址：<br><a target="_blank" rel="noopener" href="http://mirrors.hust.edu.cn/apache/hadoop/common/hadoop-3.3.0/">http://mirrors.hust.edu.cn/apache/hadoop/common/hadoop-3.3.0/</a></p>
<p><img src="C:\Users\Hasee\AppData\Roaming\Typora\typora-user-images\image-20210115102346130.png"></p>
<ol>
<li><p>切换到想要下载的目录，使用命令下载到虚拟机上，前提是要确保虚拟机能够连接上外网。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.hust.edu.cn/apache/hadoop/common/hadoop-3.3.0/hadoop-3.3.0.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个存放hadoop文件的目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/hadoop</span><br></pre></td></tr></table></figure></li>
<li><p>切换到hadoop安装包路径，解压hadoop安装包到创建的目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf hadoop-3.1.1.tar.gz -C /usr/local/hadoop</span><br></pre></td></tr></table></figure></li>
<li><p>开始配置hadoop环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure>

<p>进入编辑状态，配置下列信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/local/hadoop</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure>

<p>让环境变量立即生效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p>检验hadoop 环境变量配置是否生效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop version</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190426151030284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1NTQyODc5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>开始进行hadoop的集群文件配置，在配置前，我们只需要对一台虚拟机（节点）配置就可以，其余3台虚拟机（3个节点）只需要将配置好的那台虚拟机复制过来就可以了。</p>
<h4 id="配置文件目录-（在安装目录-usr-local-hadoop-etc-hadoop-下）"><a href="#配置文件目录-（在安装目录-usr-local-hadoop-etc-hadoop-下）" class="headerlink" title="配置文件目录 （在安装目录 /usr/local/hadoop/etc/hadoop/ 下）"></a>配置文件目录 （在安装目录 /usr/local/hadoop/etc/hadoop/ 下）</h4><ul>
<li><strong><a target="_blank" rel="noopener" href="http://hadoop-env.sh/">hadoop-env.sh</a></strong></li>
<li><strong>core-site.xml</strong></li>
<li><strong>hdfs-site.xml</strong></li>
<li><strong>mapred-site.xml</strong></li>
<li><strong>yarn-site.xml</strong></li>
<li><strong>workers</strong></li>
</ul>
</li>
</ol>
<h3 id="hadoop文件配置"><a href="#hadoop文件配置" class="headerlink" title="hadoop文件配置"></a>hadoop文件配置</h3><ul>
<li><p>首先，配置hadoop-env.sh文件，如图所示：<br><img src="https://img-blog.csdnimg.cn/20190426151104960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1NTQyODc5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>找到已经注释了”export JAVA_HOME”的代码行，按照上图写入对应的变量。</p>
<p><strong>参考代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_211</span><br><span class="line">export HADOOP_PID_DIR=/usr/local/hadoop/hadoop_data/tmp/pids</span><br><span class="line">export HDFS_NAMENODE_USER=root</span><br><span class="line">export HDFS_DATANODE_USER=root</span><br><span class="line">export HDFS_SECONDARYNAMENODE_USER=root</span><br><span class="line">export YARN_RESOURCEMANAGER_USER=root</span><br><span class="line">export YARN_NODEMANAGER_USER=root</span><br></pre></td></tr></table></figure>

<h4 id="配置注意事项"><a href="#配置注意事项" class="headerlink" title="配置注意事项"></a>配置注意事项</h4><p>1.JAVA_HOME的路径一定要填写绝对路径！</p>
<p>2.HADOOP_PID_DIR的值可以先填上去，后面再去创建，创建的时候最好放在hadoop安装目录下，而且只需要创建到tmp文件夹就行，pids会自动生成，方便拷贝到其他节点（虚拟机）上</p>
<p>3.其余的KEY对应的值都是root，按照上图配置就好了</p>
</li>
<li><p>配置core-site.xml文件，如图所示：<br><img src="https://pics6.baidu.com/feed/314e251f95cad1c88f206fc6ecb93f0ecb3d51c2.jpeg?token=b5fa84e23d3c752917fde19977af63c8" alt="img"></p>
<p><strong>参考代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">	        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">	        &lt;value&gt;hdfs://hadoop1:9000&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">	        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">	        &lt;value&gt;/usr/local/hadoop/hadoop_data/tmp&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	&lt;!-- 当前用户全设置成root --&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.http.staticuser.user&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;root&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h4 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h4><ul>
<li><strong>fs.defaultFS</strong>  hadoop系统需要手动指定默认文件系统为HDFS，并且在众多服务器中指定其中一台作为name node服务器</li>
<li><strong>hadoop.tmp.dir</strong> 配置hadoop存储临时文件的路径</li>
<li><strong>我们需要手动创建这个目录，上面的步骤已经说明了</strong></li>
</ul>
</li>
<li><p>配置hdfs-site.xml文件，如图所示：<br><img src="https://img-blog.csdnimg.cn/20190426151434502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1NTQyODc5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>默认情况下name node和data node配置文件存储在tmp目录下，但这是危险的，必须通过手动修改配置文件的存储路径。第一台name node服务器需要同时配置name node和data node配置文件路径，其他服务器只需要改data node路径即可；通过修改 hdfs-site.xml 配置文件实现。</p>
<p><strong>参考代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">            &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;3&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">            &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;/hadoop3/namenode&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">            &lt;name&gt;dfs.datanode.name.dir&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;/hadoop3/datanode&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">            &lt;name&gt;dfs.namenode.http-address&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;hadoop1:50070&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">            &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;hadoop2:50090&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h4 id="配置说明-1"><a href="#配置说明-1" class="headerlink" title="配置说明"></a>配置说明</h4><ul>
<li><strong>dfs.replication</strong> 设置文件的备份数量</li>
<li><strong>dfs.namenode.http-address</strong> 设置哪台虚拟机作为namenode节点</li>
<li><strong>dfs.namenode.secondary.http-address</strong> 设置哪台虚拟机作为冷备份namenode节点，用于辅助namenode</li>
</ul>
</li>
<li><p>配置mapred-site.xml文件，如图所示：<br><img src="https://img-blog.csdnimg.cn/20190426151450178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1NTQyODc5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>参考代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">            &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h4 id="配置说明-2"><a href="#配置说明-2" class="headerlink" title="配置说明"></a>配置说明</h4><ul>
<li><strong><a target="_blank" rel="noopener" href="http://mapreduce.framework.name/">mapreduce.framework.name</a></strong> 配置yarn来进行任务调度</li>
</ul>
</li>
<li><p>配置yarn-site.xml文件，如图所示：<br><img src="https://img-blog.csdnimg.cn/20190426151500367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1NTQyODc5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>参考代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">	&lt;!-- Site specific YARN configuration properties --&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">	        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">	        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">	        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">	        &lt;value&gt;hadoop2&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">	&lt;property&gt;</span><br><span class="line">    		&lt;name&gt;yarn.application.classpath&lt;/name&gt;</span><br><span class="line"> 			&lt;value&gt;/usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/*:/usr/local/hadoop/share/hadoop/common/*:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/*:/usr/local/hadoop/share/hadoop/hdfs/*:/usr/local/hadoop/share/hadoop/mapreduce/lib/*:/usr/local/hadoop/share/hadoop/mapreduce/*:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/*:/usr/local/hadoop/share/hadoop/yarn/*&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h4 id="配置说明-3"><a href="#配置说明-3" class="headerlink" title="配置说明"></a>配置说明</h4><ul>
<li><strong>yarn.resourcemanager.hostname</strong> 配置yarn启动的主机名，也就是说配置在哪台虚拟机上就在那台虚拟机上进行启动</li>
<li><strong>yarn.application.classpath</strong> 配置yarn执行任务调度的类路径，如果不配置，yarn虽然可以启动，但执行不了mapreduce。执行<strong>hadoop classpath</strong>命令,将出现的类路径放在<value>标签里<br><strong>(注：其他机器启动是没有效果的）</strong></li>
</ul>
</li>
<li><p>配置workers文件，如图所示：<br><img src="https://img-blog.csdnimg.cn/20190426151514490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1NTQyODc5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>参考代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop1</span><br><span class="line">hadoop2</span><br><span class="line">hadoop3</span><br></pre></td></tr></table></figure>

<h4 id="配置说明-4"><a href="#配置说明-4" class="headerlink" title="配置说明"></a>配置说明</h4><ul>
<li><strong>workers</strong> 配置datanode工作的机器，而datanode主要是用来存放数据文件的，我这里配置了4台，可能你会疑惑，hadoop1怎么也可以配置进去。其实，hadoop1我既配置作为namenode，它也可以充当datanode。当然你也可以选择不将namenode节点也配置进来。</li>
</ul>
</li>
<li><p>以上文件配置完毕之后，我们就可以用这台配置好的节点进行远程拷贝了。</p>
<p><strong>1</strong>. 首先，我们需要前期准备工作，先把其余有安装过hadoop的机器进行清除，在安装路径统一的情况下，这样方便我们前期的清理。<br>假设我配置好的文件放在hadoop1节点上，我将执行如下步骤：</p>
<ul>
<li><p>免密登陆到节点hadoop2,执行清理hadoop安装目录（其他机器没有安装的朋友可以不用操作此步骤）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh hadoop2 </span><br><span class="line">rm -rf /usr/local/hadoop</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></li>
</ul>
<p>同理，按照上述步骤清理其余机器hadoop的安装目录</p>
<p><strong>2</strong>. 然后，我们进行远程拷贝操作，有两份需要拷贝，一份是环境变量，一份是hadoop的安装文件</p>
<ul>
<li><p>我们在当前配置过的节点hadoop1上执行远程拷贝命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">scp -r /usr/local/hadoop hadoop2:/usr/local</span><br><span class="line">scp -r /etc/profile hadoop2:/etc</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 拷贝完成之后，我们远程到hadoop2上，让环境变量立即生效</span><br><span class="line"></span><br></pre></td></tr></table></figure>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh hadoop2</span><br><span class="line">source /etc/profile</span><br><span class="line">hadoop version</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  如果控制台显示出hadoop版本信息，则环境变量生效，执行退出 `exit`</span><br><span class="line"></span><br><span class="line">- 同理，按照上述步骤去远程拷贝其余节点</span><br><span class="line"></span><br><span class="line">**3**. 搭建工作已经全部就绪，现在我们要来启动hadoop。如果有将hadoop的sbin和bin路径配置到环境变量PATH路径上则不用切换到如下路径：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>cd /usr/local/hadoop/bin</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 首先，我们要对namenode进行格式化：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>hdfs namenode -format</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 如果严格按照上述配置执行，那格式化namenode是不会失败的，如果失败，请到各个节点的tmp路径进行删除操作，然后重新格式化namenode。</span><br><span class="line"></span><br><span class="line">  切换到sbin路径上，启动hdfs:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>cd /usr/local/hadoop/sbin</p>
<p>./start-dfs.sh</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  启动成功之后，使用`jps`可以看到各个节点的进程。</span><br><span class="line"></span><br><span class="line">  hadoop1的进程，如图：</span><br><span class="line">  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426151620386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1NTQyODc5,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">  hadoop2的进程，如图：</span><br><span class="line">  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426151629829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1NTQyODc5,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">  hadoop3的进程，如图：</span><br><span class="line">  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426151638234.png)</span><br><span class="line"></span><br><span class="line">  hadoop4的进程，如图：</span><br><span class="line">  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426151646239.png)</span><br><span class="line"></span><br><span class="line">**4**.接下来，我们可以打开hadoop自带的管理也页面。在浏览器上输入：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>hadoop1:50070</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如图：</span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426151655743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1NTQyODc5,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">想要检查是否4台机器已经做了集群也可以在上面看，如图红框部分显示4个存活节点：</span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426151706121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1NTQyODc5,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">**5**.这还不算搭建完成，还需要启动yarn来进行任务调度，我们远程到hadoop2街店切换到sbin路径下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ssh hadoop2<br>cd  /usr/local/hadoop/sbin<br>./start-yarn.sh</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**启动成功之后，hadoop2的进程界面如图：**</span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426151717336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1NTQyODc5,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">**在浏览器上输入：**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>hadoop2:8088<br>```</p>
</li>
</ul>
<p>yarn的管理界面：<br><img src="https://img-blog.csdnimg.cn/20190426151729686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1NTQyODc5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>6</strong>. 最后，<strong>hadoop搭建大功告成</strong>，接下来就可以进行hadoop命令进行文件操作和并行计算了。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/15/Hadoop%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%EF%BC%88Hadoop3.3.0%EF%BC%89/" data-id="clh04c6dd0004o4rgct9w6imh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux系统配置免密码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/12/linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%85%8D%E5%AF%86%E7%A0%81/" class="article-date">
  <time datetime="2021-01-12T08:39:43.154Z" itemprop="datePublished">2021-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="linux系统配置免密码"><a href="#linux系统配置免密码" class="headerlink" title="linux系统配置免密码"></a><strong>linux系统配置免密码</strong></h1><p><strong>一、需求：</strong><br>假设 A 为客户机器，B为目标机, 要达到的目如下：<br>A机器ssh登录B机器无需输入密码；<br>加密方式选 rsa|dsa均可以，默认dsa </p>
<p><strong>二、常用解决方式：</strong><br>1、登录A机器<br>2、ssh-keygen -t [rsa|dsa]，将会生成密钥文件和私钥文件 id_rsa,id_rsa.pub或id_dsa,id_dsa.pub<br>    例如：ssh-keygen -t rsa -C  “372338206qq.com”<br>    -C : 表示注释的意思<br>3、将 xxxx.pub的 文件复制到B机器的 .ssh 目录中， 并执行 #cat id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys<br>4、操作完成，验证从A机器登录B机器的目标账户，是否还需要密码。 </p>
<p>如果想要B可无密登陆A，操作做个逆向即可。</p>
<p><strong>三、linux系统配置免密码的快捷方式：</strong></p>
<p>使用ssh-keygen 创建公钥和密钥。<br>使用ssh-copy-id命令传送文件<br>ssh-copy-id 把本地主机的公钥复制到远程主机的authorized_keys文件上。<br>ssh-copy-id 也会给远程主机的用户主目录（home）和<del>/.ssh, 和</del>/.ssh/authorized_keys设置合适的权限 。</p>
<p>实例展示：<br>1：生成密钥<br># ssh-keygen -t rsa -C<br>2：把本机的公钥追到192.168.0.1的root目录下的.ssh/authorized_keys文件里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.0.1</span><br></pre></td></tr></table></figure>

<p>注：如果ssh的端口不是22，可用下面命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ssh-copy-id -i ~/.ssh/id_rsa.pub  -p 23 root@192.168.0.1</span><br></pre></td></tr></table></figure>

<p><strong>四、ssh启动和停止</strong></p>
<p>停止:   service sshd stop</p>
<p>启动：service sshd start</p>
<p>调试： /usr/sbin/sshd -d</p>
<p><strong>五、遇到的问题</strong></p>
<ol>
<li><p>首先保证ssh服务是启动的</p>
</li>
<li><p>修改配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile    %h/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></li>
<li></li>
</ol>
<p><strong>六、日志查看</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tailf /var/log/secure</span><br><span class="line">ssh -v pre1</span><br></pre></td></tr></table></figure>

<p><strong>七、ssh无密码登陆 Authentication refused: bad ownership or modes for directory /root</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line"></span><br><span class="line">chmod  0700 /root -R</span><br><span class="line"></span><br><span class="line">or chown root.root root</span><br></pre></td></tr></table></figure>



<p>注意：<br><strong>要保证.ssh和authorized_keys都只有用户自己有写权限。否则验证无效。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//用户权限</span><br><span class="line">chmod 700 /home/username |   /root</span><br><span class="line">//.ssh文件夹权限</span><br><span class="line">chmod 700 ~/.ssh/x	</span><br><span class="line">// ~/.ssh/authorized_keys 文件权限</span><br><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/12/linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%85%8D%E5%AF%86%E7%A0%81/" data-id="clh04c6dq000jo4rg1ovdcov6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务网关zuul之三：zuul统一异常处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/12/%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3zuul%E4%B9%8B%E4%B8%89%EF%BC%9Azuul%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" class="article-date">
  <time datetime="2021-01-12T06:26:42.730Z" itemprop="datePublished">2021-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="服务网关zuul之三：zuul统一异常处理"><a href="#服务网关zuul之三：zuul统一异常处理" class="headerlink" title="                   服务网关zuul之三：zuul统一异常处理"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duanxz/p/7543040.html">                   服务网关zuul之三：zuul统一异常处理</a></h1><p>我们详细介绍了Spring Cloud Zuul中自己实现的一些核心过滤器，以及这些过滤器在请求生命周期中的不同作用。我们会发现在这些核心过滤器中并没有实现error阶段的过滤器。那么这些过滤器可以用来做什么呢？接下来，本文将介绍如何利用error过滤器来实现统一的异常处理。</p>
<h2 id="过滤器中抛出异常的问题"><a href="#过滤器中抛出异常的问题" class="headerlink" title="过滤器中抛出异常的问题"></a>过滤器中抛出异常的问题</h2><p>首先，我们可以来看看默认情况下，过滤器中抛出异常Spring Cloud Zuul会发生什么现象。我们创建一个pre类型的过滤器，并在该过滤器的run方法实现中抛出一个异常。比如下面的实现，在run方法中调用的<code>doSomething</code>方法将抛出<code>RuntimeException</code>异常。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.dxz.zuul;</span><br><span class="line"></span><br><span class="line">import org.apache.log4j.Logger;</span><br><span class="line">import com.netflix.zuul.ZuulFilter;</span><br><span class="line"></span><br><span class="line">public class ThrowExceptionFilter extends ZuulFilter &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger log = Logger.getLogger(ThrowExceptionFilter.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String filterType() &#123;</span><br><span class="line">        return &quot;pre&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int filterOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldFilter() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object run() &#123;</span><br><span class="line">        log.info(&quot;This is a pre filter, it will throw a RuntimeException&quot;);</span><br><span class="line">        doSomething();</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void doSomething() &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Exist some errors...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>在启动类为自定义过滤器创建具体的Bean才能启动该过滤器，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ThrowExceptionFilter throwExceptionFilter() &#123;</span><br><span class="line">    return new ThrowExceptionFilter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行网关程序并访问某个路由请求，此时我们会发现：在API网关服务的控制台中输出了ThrowExceptionFilter的过滤逻辑中的日志信息，但是并没有输出任何异常信息，同时发起的请求也没有获得任何响应结果。为什么会出现这样的情况呢？我们又该如何在过滤器中处理异常呢？</p>
<h3 id="解决方案一：严格的try-catch处理"><a href="#解决方案一：严格的try-catch处理" class="headerlink" title="解决方案一：严格的try-catch处理"></a><strong>解决方案一：严格的try-catch处理</strong></h3><p>　　运行网关程序并访问某个路由请求，此时我们会发现：在API网关服务的控制台中输出了<code>ThrowExceptionFilter</code>的过滤逻辑中的日志信息，但是并没有输出任何异常信息，同时发起的请求也没有获得任何响应结果。为什么会出现这样的情况呢？我们又该如何在过滤器中处理异常呢？</p>
<p>回想一下，我们在上一节中介绍的所有核心过滤器，是否还记得有一个<code>post</code>过滤器<code>SendErrorFilter</code>是用来处理异常信息的？根据正常的处理流程，该过滤器会处理异常信息，那么这里没有出现任何异常信息说明很有可能就是这个过滤器没有被执行。所以，我们不妨来详细看看<code>SendErrorFilter</code>的<code>shouldFilter</code>函数：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean shouldFilter() &#123;</span><br><span class="line">    RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">    // only forward to errorPath if it hasn&#x27;t been forwarded to already</span><br><span class="line">    return ctx.containsKey(&quot;error.status_code&quot;)</span><br><span class="line">            &amp;&amp; !ctx.getBoolean(SEND_ERROR_FILTER_RAN, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><img src="https://images2017.cnblogs.com/blog/285763/201709/285763-20170918150433150-2013481451.png" alt="img"></p>
<p>可以看到该方法的返回值中有一个重要的判断依据<code>ctx.containsKey(&quot;error.status_code&quot;)</code>，也就是说请求上下文中必须有<code>error.status_code</code>参数，我们实现的<code>ThrowExceptionFilter</code>中并没有设置这个参数，所以自然不会进入<code>SendErrorFilter</code>过滤器的处理逻辑。那么我们要如何用这个参数呢？我们可以看一下<code>route</code>类型的几个过滤器，由于这些过滤器会对外发起请求，所以肯定会有异常需要处理，比如spring-cloud-netflix-core-1.1.4.RELEASE.jar中的org.springframework.cloud.netflix.zuul.filters.route.<code>RibbonRoutingFilter</code>的<code>run</code>方法实现如下：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object run() &#123;</span><br><span class="line">    RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">    this.helper.addIgnoredHeaders();</span><br><span class="line">    try &#123;</span><br><span class="line">        RibbonCommandContext commandContext = buildCommandContext(context);</span><br><span class="line">        ClientHttpResponse response = forward(commandContext);</span><br><span class="line">        setResponse(response);</span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ZuulException ex) &#123;</span><br><span class="line">        context.set(ERROR_STATUS_CODE, ex.nStatusCode);</span><br><span class="line">        context.set(&quot;error.message&quot;, ex.errorCause);</span><br><span class="line">        context.set(&quot;error.exception&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex) &#123;</span><br><span class="line">        context.set(&quot;error.status_code&quot;,</span><br><span class="line">                HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line">        context.set(&quot;error.exception&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>可以看到，整个发起请求的逻辑都采用了<code>try-catch</code>块处理。在<code>catch</code>异常的处理逻辑中并没有做任何输出操作，而是往请求上下文中添加一些<code>error</code>相关的参数，主要有下面三个参数：</p>
<ul>
<li><code>error.status_code</code>：错误编码</li>
<li><code>error.exception</code>：<code>Exception</code>异常对象</li>
<li><code>error.message</code>：错误信息</li>
</ul>
<p>其中，<code>error.status_code</code>参数就是<code>SendErrorFilter</code>过滤器用来判断是否需要执行的重要参数。分析到这里，实现异常处理的大致思路就开始明朗了，我们可以参考<code>RibbonRoutingFilter</code>的实现对<code>ThrowExceptionFilter</code>的<code>run</code>方法做一些异常处理的改造，具体如下：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object run() &#123;</span><br><span class="line">    log.info(&quot;This is a pre filter, it will throw a RuntimeException&quot;);</span><br><span class="line">    RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">    try &#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        ctx.set(&quot;error.status_code&quot;, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line">        ctx.set(&quot;error.exception&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>通过上面的改造之后，我们再尝试访问之前的接口，这个时候我们可以得到如下响应内容：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;timestamp&quot;: 1481674980376,</span><br><span class="line">&quot;status&quot;: 500,</span><br><span class="line">&quot;error&quot;: &quot;Internal Server Error&quot;,</span><br><span class="line">&quot;exception&quot;: &quot;java.lang.RuntimeException&quot;,</span><br><span class="line">&quot;message&quot;: &quot;Exist some errors...&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>此时，我们的异常信息已经被<code>SendErrorFilter</code>过滤器正常处理并返回给客户端了，同时在网关的控制台中也输出了异常信息。从返回的响应信息中，我们可以看到几个我们之前设置在请求上下文中的内容，它们的对应关系如下：</p>
<ul>
<li><code>status</code>：对应<code>error.status_code</code>参数的值</li>
<li><code>exception</code>：对应<code>error.exception</code>参数中<code>Exception</code>的类型</li>
<li><code>message</code>：对应<code>error.exception</code>参数中<code>Exception</code>的<code>message</code>信息。对于<code>message</code>的信息，我们在过滤器中还可以通过<code>ctx.set(&quot;error.message&quot;, &quot;自定义异常消息&quot;);</code>来定义更友好的错误信息。<code>SendErrorFilter</code>会优先取<code>error.message</code>来作为返回的<code>message</code>内容，如果没有的话才会使用<code>Exception</code>中的<code>message</code>信息</li>
</ul>
<h3 id="解决方案二：ErrorFilter处理"><a href="#解决方案二：ErrorFilter处理" class="headerlink" title="解决方案二：ErrorFilter处理"></a>解决方案二：ErrorFilter处理</h3><p>通过上面的分析与实验，我们已经知道如何在过滤器中正确的处理异常，让错误信息能够顺利地流转到后续的<code>SendErrorFilter</code>过滤器来组织和输出。但是，即使我们不断强调要在过滤器中使用<code>try-catch</code>来处理业务逻辑并往请求上下文添加异常信息，但是不可控的人为因素、意料之外的程序因素等，依然会使得一些异常从过滤器中抛出，对于意外抛出的异常又会导致没有控制台输出也没有任何响应信息的情况出现，那么是否有什么好的方法来为这些异常做一个统一的处理呢？</p>
<p>这个时候，我们就可以用到<code>error</code>类型的过滤器了。由于在请求生命周期的<code>pre</code>、<code>route</code>、<code>post</code>三个阶段中有异常抛出的时候都会进入<code>error</code>阶段的处理，所以我们可以通过创建一个<code>error</code>类型的过滤器来捕获这些异常信息，并根据这些异常信息在请求上下文中注入需要返回给客户端的错误描述，这里我们可以直接沿用在<code>try-catch</code>处理异常信息时用的那些error参数，这样就可以让这些信息被<code>SendErrorFilter</code>捕获并组织成消息响应返回给客户端。比如，下面的代码就实现了这里所描述的一个过滤器：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.dxz.zuul;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line">import com.netflix.zuul.ZuulFilter;</span><br><span class="line">import com.netflix.zuul.context.RequestContext;</span><br><span class="line"></span><br><span class="line">public class ErrorFilter extends ZuulFilter &#123;</span><br><span class="line"></span><br><span class="line">    Logger log = Logger.getLogger(ErrorFilter.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String filterType() &#123;</span><br><span class="line">        return &quot;error&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int filterOrder() &#123;</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldFilter() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object run() &#123;</span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        Throwable throwable = ctx.getThrowable();</span><br><span class="line">        log.error(&quot;this is a ErrorFilter :&quot; + throwable.getCause().getMessage(), throwable);</span><br><span class="line">        ctx.set(&quot;error.status_code&quot;, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line">        ctx.set(&quot;error.exception&quot;, throwable.getCause());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>在启动类为自定义过滤器创建具体的Bean才能启动该过滤器，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ErrorFilter errorFilter() &#123;</span><br><span class="line">    return new ErrorFilter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改并保留ThrowExceptionFilter，</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object run() &#123;</span><br><span class="line">    log.info(&quot;This is a pre filter, it will throw a RuntimeException&quot;);</span><br><span class="line">    doSomething();</span><br><span class="line">    /*RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">    try &#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        ctx.set(&quot;error.status_code&quot;, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line">        ctx.set(&quot;error.exception&quot;, e);</span><br><span class="line">    &#125;*/</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>在将该过滤器加入到我们的API网关服务之后，我们可以尝试使用之前介绍<code>try-catch</code>处理时实现的<code>ThrowExceptionFilter</code>（不包含异常处理机制的代码），让该过滤器能够抛出异常。这个时候我们再通过API网关来访问服务接口。此时，我们就可以在控制台中看到<code>ThrowExceptionFilter</code>过滤器抛出的异常信息，并且请求响应中也能获得如下的错误信息内容，而不是什么信息都没有的情况了。</p>
<p><img src="https://images2017.cnblogs.com/blog/285763/201709/285763-20170918151619368-1555310138.png" alt="img"></p>
<p>两种解决方案：一种是通过在各个阶段的过滤器中增加<code>try-catch</code>块，实现过滤器内部的异常处理；另一种是利用<code>error</code>类型过滤器的生命周期特性，集中地处理<code>pre</code>、<code>route</code>、<code>post</code>阶段抛出的异常信息。通常情况下，我们可以将这两种手段同时使用，其中第一种是对开发人员的基本要求；而第二种是对第一种处理方式的补充，以防止一些意外情况的发生。这样的异常处理机制看似已经完美，但是如果在多一些应用实践或源码分析之后，我们会发现依然存在一些不足。</p>
<h3 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h3><p>下面，我们不妨跟着源码来看看，到底上面的方案还有哪些不足之处需要我们注意和进一步优化的。先来看看外部请求到达API网关服务之后，各个阶段的过滤器是如何进行调度的：</p>
<p><img src="https://images2017.cnblogs.com/blog/285763/201709/285763-20170918154940556-1741762725.png" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void service(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse) throws ServletException, IOException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);</span><br><span class="line"></span><br><span class="line">        // Marks this request as having passed through the &quot;Zuul engine&quot;, as opposed to servlets</span><br><span class="line">        // explicitly bound in web.xml, for which requests will not have the same data attached</span><br><span class="line">        RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">        context.setZuulEngineRan();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            preRoute();</span><br><span class="line">        &#125; catch (ZuulException e) &#123;</span><br><span class="line">            error(e);</span><br><span class="line">            postRoute();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            route();</span><br><span class="line">        &#125; catch (ZuulException e) &#123;</span><br><span class="line">            error(e);</span><br><span class="line">            postRoute();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            postRoute();</span><br><span class="line">        &#125; catch (ZuulException e) &#123;</span><br><span class="line">            error(e);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        error(new ZuulException(e, 500, &quot;UNHANDLED_EXCEPTION_&quot; + e.getClass().getName()));</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        RequestContext.getCurrentContext().unset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>问题分析与进一步优化上面代码源自<code>com.netflix.zuul.http.ZuulServlet</code>的<code>service</code>方法实现，它定义了Zuul处理外部请求过程时，各个类型过滤器的执行逻辑。从代码中我们可以看到三个<code>try-catch</code>块，它们依次分别代表了<code>pre</code>、<code>route</code>、<code>post</code>三个阶段的过滤器调用，在<code>catch</code>的异常处理中我们可以看到它们都会被<code>error</code>类型的过滤器进行处理（之前使用<code>error</code>过滤器来定义统一的异常处理也正是利用了这个特性）；<code>error</code>类型的过滤器处理完毕之后，除了来自<code>post</code>阶段的异常之外，都会再被<code>post</code>过滤器进行处理。而对于从<code>post</code>过滤器中抛出异常的情况，在经过了<code>error</code>过滤器处理之后，就没有其他类型的过滤器来接手了，这就是使用之前所述方案存在不足之处的根源。</p>
<p>回想一下之前实现的两种异常处理方法，其中非常核心的一点，这两种处理方法都在异常处理时候往请求上下文中添加了一系列的<code>error.*</code>参数，而这些参数真正起作用的地方是在<code>post</code>阶段的<code>SendErrorFilter</code>，在该过滤器中会使用这些参数来组织内容返回给客户端。而对于<code>post</code>阶段抛出异常的情况下，由<code>error</code>过滤器处理之后并不会在调用<code>post</code>阶段的请求，自然这些<code>error.*</code>参数也就不会被<code>SendErrorFilter</code>消费输出。所以，如果我们在自定义<code>post</code>过滤器的时候，没有正确的处理异常，就依然有可能出现日志中没有异常并且请求响应内容为空的问题。我们可以通过修改之前<code>ThrowExceptionFilter</code>的<code>filterType</code>修改为<code>post</code>来验证这个问题的存在，注意去掉<code>try-catch</code>块的处理，让它能够抛出异常。</p>
<p>解决上述问题的方法有很多种，比如最直接的我们可以在实现<code>error</code>过滤器的时候，直接来组织结果返回就能实现效果，但是这样的缺点也很明显，对于错误信息组织和返回的代码实现就会存在多份，这样非常不易于我们日后的代码维护工作。所以为了保持对异常返回处理逻辑的一致，我们还是希望将<code>post</code>过滤器抛出的异常能够交给<code>SendErrorFilter</code>来处理。</p>
<p>在前文中，我们已经实现了一个<code>ErrorFilter</code>来捕获<code>pre</code>、<code>route</code>、<code>post</code>过滤器抛出的异常，并组织<code>error.*</code>参数保存到请求的上下文中。由于我们的目标是沿用<code>SendErrorFilter</code>，这些<code>error.*</code>参数依然对我们有用，所以我们可以继续沿用该过滤器，让它在<code>post</code>过滤器抛出异常的时候，继续组织<code>error.*</code>参数，只是这里我们已经无法将这些<code>error.*</code>参数再传递给<code>SendErrorFitler</code>过滤器来处理了。所以，我们需要在<code>ErrorFilter</code>过滤器之后再定义一个<code>error</code>类型的过滤器，让它来实现<code>SendErrorFilter</code>的功能，但是这个<code>error</code>过滤器并不需要处理所有出现异常的情况，它仅对<code>post</code>过滤器抛出的异常才有效。根据上面的思路，我们完全可以创建一个继承自<code>SendErrorFilter</code>的过滤器，就能复用它的<code>run</code>方法，然后重写它的类型、顺序以及执行条件，实现对原有逻辑的复用，具体实现如下：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.dxz.zuul;</span><br><span class="line"></span><br><span class="line">import org.springframework.cloud.netflix.zuul.filters.post.SendErrorFilter;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class ErrorExtFilter extends SendErrorFilter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String filterType() &#123;</span><br><span class="line">        return &quot;error&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int filterOrder() &#123;</span><br><span class="line">        return 30; // 大于ErrorFilter的值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldFilter() &#123;</span><br><span class="line">        // TODO 判断：仅处理来自post过滤器引起的异常</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>到这里，我们在过滤器调度上的实现思路已经很清晰了，但是又有一个问题出现在我们面前：怎么判断引起异常的过滤器是来自什么阶段呢？（<code>shouldFilter</code>方法该如何实现）对于这个问题，我们第一反应会寄希望于请求上下文<code>RequestContext</code>对象，可是在查阅文档和源码后发现其中并没有存储异常来源的内容，所以我们不得不扩展原来的过滤器处理逻辑，当有异常抛出的时候，记录下抛出异常的过滤器，这样我们就可以在<code>ErrorExtFilter</code>过滤器的<code>shouldFilter</code>方法中获取并以此判断异常是否来自<code>post</code>阶段的过滤器了。</p>
<p>为了扩展过滤器的处理逻辑，为请求上下文增加一些自定义属性，我们需要深入了解一下Zuul过滤器的核心处理器：<code>com.netflix.zuul.FilterProcessor</code>。该类中定义了下面过滤器调用和处理相关的核心方法：到这里，我们在过滤器调度上的实现思路已经很清晰了，但是又有一个问题出现在我们面前：怎么判断引起异常的过滤器是来自什么阶段呢？（<code>shouldFilter</code>方法该如何实现）对于这个问题，我们第一反应会寄希望于请求上下文<code>RequestContext</code>对象，可是在查阅文档和源码后发现其中并没有存储异常来源的内容，所以我们不得不扩展原来的过滤器处理逻辑，当有异常抛出的时候，记录下抛出异常的过滤器，这样我们就可以在<code>ErrorExtFilter</code>过滤器的<code>shouldFilter</code>方法中获取并以此判断异常是否来自<code>post</code>阶段的过滤器了。</p>
<ul>
<li><code>getInstance()</code>：该方法用来获取当前处理器的实例</li>
<li><code>setProcessor(FilterProcessor processor)</code>：该方法用来设置处理器实例，可以使用此方法来设置自定义的处理器</li>
<li><code>processZuulFilter(ZuulFilter filter)</code>：该方法定义了用来执行<code>filter</code>的具体逻辑，包括对请求上下文的设置，判断是否应该执行，执行时一些异常处理等</li>
<li><code>getFiltersByType(String filterType)</code>：该方法用来根据传入的<code>filterType</code>获取API网关中对应类型的过滤器，并根据这些过滤器的<code>filterOrder</code>从小到大排序，组织成一个列表返回</li>
<li><code>runFilters(String sType)</code>：该方法会根据传入的<code>filterType</code>来调用<code>getFiltersByType(String filterType)</code>获取排序后的过滤器列表，然后轮询这些过滤器，并调用<code>processZuulFilter(ZuulFilter filter)</code>来依次执行它们</li>
<li><code>preRoute()</code>：调用<code>runFilters(&quot;pre&quot;)</code>来执行所有<code>pre</code>类型的过滤器</li>
<li><code>route()</code>：调用<code>runFilters(&quot;route&quot;)</code>来执行所有<code>route</code>类型的过滤器</li>
<li><code>postRoute()</code>：调用<code>runFilters(&quot;post&quot;)</code>来执行所有<code>post</code>类型的过滤器</li>
<li><code>error()</code>：调用<code>runFilters(&quot;error&quot;)</code>来执行所有<code>error</code>类型的过滤器</li>
</ul>
<p>根据我们之前的设计，我们可以直接通过扩展<code>processZuulFilter(ZuulFilter filter)</code>方法，当过滤器执行抛出异常的时候，我们捕获它，并往请求上下中记录一些信息。比如下面的具体实现：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.dxz.zuul;</span><br><span class="line"></span><br><span class="line">import com.netflix.zuul.FilterProcessor;</span><br><span class="line">import com.netflix.zuul.ZuulFilter;</span><br><span class="line">import com.netflix.zuul.context.RequestContext;</span><br><span class="line">import com.netflix.zuul.exception.ZuulException;</span><br><span class="line"></span><br><span class="line">public class DidiFilterProcessor extends FilterProcessor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object processZuulFilter(ZuulFilter filter) throws ZuulException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return super.processZuulFilter(filter);</span><br><span class="line">        &#125; catch (ZuulException e) &#123;</span><br><span class="line">            RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">            ctx.set(&quot;failed.filter&quot;, filter);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>在上面代码的实现中，我们创建了一个<code>FilterProcessor</code>的子类，并重写了<code>processZuulFilter(ZuulFilter filter)</code>，虽然主逻辑依然使用了父类的实现，但是在最外层，我们为其增加了异常捕获，并在异常处理中为请求上下文添加了<code>failed.filter</code>属性，以存储抛出异常的过滤器实例。在实现了这个扩展之后，我们也就可以完善之前<code>ErrorExtFilter</code>中的<code>shouldFilter()</code>方法，通过从请求上下文中获取该信息作出正确的判断，具体实现如下：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.dxz.zuul;</span><br><span class="line"></span><br><span class="line">import org.springframework.cloud.netflix.zuul.filters.post.SendErrorFilter;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import com.netflix.zuul.ZuulFilter;</span><br><span class="line">import com.netflix.zuul.context.RequestContext;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class ErrorExtFilter extends SendErrorFilter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String filterType() &#123;</span><br><span class="line">        return &quot;error&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int filterOrder() &#123;</span><br><span class="line">        return 30; // 大于ErrorFilter的值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldFilter() &#123;</span><br><span class="line">        // 判断：仅处理来自post过滤器引起的异常</span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        ZuulFilter failedFilter = (ZuulFilter) ctx.get(&quot;failed.filter&quot;);</span><br><span class="line">        if (failedFilter != null &amp;&amp; failedFilter.filterType().equals(&quot;post&quot;)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>到这里，我们的优化任务还没有完成，因为扩展的过滤器处理类并还没有生效。最后，我们需要在应用主类中，通过调用<code>FilterProcessor.setProcessor(new DidiFilterProcessor());</code>方法来启用自定义的核心处理器以完成我们的优化目标。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/12/%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3zuul%E4%B9%8B%E4%B8%89%EF%BC%9Azuul%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" data-id="clh04c6dv000so4rg0rum9xqu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-关于Jib插件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/09/%E5%85%B3%E4%BA%8EJib%E6%8F%92%E4%BB%B6/" class="article-date">
  <time datetime="2021-01-09T05:38:42.497Z" itemprop="datePublished">2021-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Jib使用小结-Maven插件版"><a href="#Jib使用小结-Maven插件版" class="headerlink" title="Jib使用小结(Maven插件版)"></a><strong>Jib使用小结(Maven插件版)</strong></h1><p>近期在用Jib插件将Java工程构建成Docker镜像，使用时遇到过一些小问题，今天对这些问题做个小结；</p>
<h3 id="关于Jib插件"><a href="#关于Jib插件" class="headerlink" title="关于Jib插件"></a>关于Jib插件</h3><p>Jib是用于构建Docker镜像的Maven插件，其基本用法请参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/boling_cavalry/article/details/94355659">《Docker与Jib(maven插件版)实战》</a>一文；</p>
<h3 id="全文概览"><a href="#全文概览" class="headerlink" title="全文概览"></a>全文概览</h3><p>本文由以下几部分组成：</p>
<ol>
<li>环境信息</li>
<li>源码下载</li>
<li>小结一：三种构建参数</li>
<li>小结二：镜像的时间问题</li>
<li>小结三：多次构建后，积累的无用镜像问题</li>
<li>小结四：提升构建速度</li>
<li>小结五：将jib与mvn构建的生命周期绑定</li>
<li>小结六：父子结构的maven工程如何构建</li>
</ol>
<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ol>
<li>操作系统：CentOS Linux release 7.6.1810</li>
<li>docker：1.13.1</li>
<li>jdk：1.8.0_191</li>
<li>maven：3.6.0</li>
<li>jib插件：1.3.0</li>
</ol>
<h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><p>本次实战用到的源码是个简单的maven工程，可以从GitHub上下载本次实战的源码，地址和链接信息如下表所示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>链接</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>项目主页</td>
<td><a target="_blank" rel="noopener" href="https://github.com/zq2599/blog_demos">https://github.com/zq2599/blog_demos</a></td>
<td>该项目在GitHub上的主页</td>
</tr>
<tr>
<td>git仓库地址(https)</td>
<td><a target="_blank" rel="noopener" href="https://github.com/zq2599/blog_demos.git">https://github.com/zq2599/blog_demos.git</a></td>
<td>该项目源码的仓库地址，https协议</td>
</tr>
<tr>
<td>git仓库地址(ssh)</td>
<td><a href="mailto:&#103;&#105;&#x74;&#64;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#x6f;&#109;">&#103;&#105;&#x74;&#64;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#x6f;&#109;</a>:zq2599/blog_demos.git</td>
<td>该项目源码的仓库地址，ssh协议</td>
</tr>
</tbody></table>
<p>这个git项目中有多个文件夹，本章的源码在hellojib文件夹下，如下图红框所示：<br><img src="C:\Users\Hasee\AppData\Roaming\Typora\typora-user-images\image-20210105104246306.png" alt="image-20210105104246306"></p>
<h3 id="小结一：三种构建参数"><a href="#小结一：三种构建参数" class="headerlink" title="小结一：三种构建参数"></a>小结一：三种构建参数</h3><p>对于一个已在pom.xml中配置了jib插件的java工程来说，下面是个标准的构建命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile jib:dockerBuild</span><br></pre></td></tr></table></figure>

<p>注意上面的dockerBuild参数，该参数的意思是将镜像存入当前的镜像仓库，这样的参数一共有三种，列表说明：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>dockerBuild</td>
<td>将镜像存入当前镜像仓库，该仓库是当前docker客户端可以连接的docker daemon，一般是指本地镜像仓库</td>
</tr>
<tr>
<td>build</td>
<td>将镜像推送到远程仓库，仓库位置与镜像名字的前缀有关，一般是hub.docker.com，使用该参数时需要提前登录成功</td>
</tr>
<tr>
<td>buildTar</td>
<td>将镜像生成tar文件，保存在项目的target目录下，在任何docker环境执行 docker load –input xxx.tar即可导入到本地镜像仓库</td>
</tr>
</tbody></table>
<h3 id="小结二：镜像的时间问题"><a href="#小结二：镜像的时间问题" class="headerlink" title="小结二：镜像的时间问题"></a>小结二：镜像的时间问题</h3><p>在使用命令mvn compile jib:dockerBuild构建本地镜像时，会遇到创建时间不准的问题：<br>如下所示，bolingcavalry/hellojib是刚刚使用jib插件构建的镜像，其生成时间(CREATED字段)显示的是49 years ago：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@maven hellojib]# docker images</span><br><span class="line">REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">bolingcavalry/hellojib   0.0.1-SNAPSHOT      ef96fdd4473a        49 years ago        505 MB</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>上面显示的镜像生成时间显然是不对的，改正此问题的方法是修改pom.xml，在jib插件的container节点内增加useCurrentTimestamp节点，内容是true，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.cloud.tools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jib-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--from节点用来设置镜像的基础镜像，相当于Docerkfile中的FROM关键字--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">from</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--使用openjdk官方镜像，tag是8-jdk-stretch，表示镜像的操作系统是debian9,装好了jdk8--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">image</span>&gt;</span>openjdk:8u212-jdk-stretch<span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">to</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--镜像名称和tag，使用了mvn内置变量$&#123;project.version&#125;，表示当前工程的version--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">image</span>&gt;</span>bolingcavalry/hellojib:$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--容器相关的属性--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--jvm内存参数--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">jvmFlags</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">jvmFlag</span>&gt;</span>-Xms4g<span class="tag">&lt;/<span class="name">jvmFlag</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">jvmFlag</span>&gt;</span>-Xmx4g<span class="tag">&lt;/<span class="name">jvmFlag</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">jvmFlags</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--要暴露的端口--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">ports</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">ports</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--使用该参数将镜像的创建时间与系统时间对其--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">useCurrentTimestamp</span>&gt;</span>true<span class="tag">&lt;/<span class="name">useCurrentTimestamp</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改保存后再次构建，此时新的镜像的创建时间已经正确，显示15 seconds ago：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@maven hellojib]# docker images</span><br><span class="line">REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">bolingcavalry/hellojib   0.0.1-SNAPSHOT      ee5ba19a8016        23 seconds ago      505 MB</span><br><span class="line">&lt;none&gt;                   &lt;none&gt;              ef96fdd4473a        49 years ago        505 MB</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<h3 id="小结三：多次构建后，积累的无用镜像"><a href="#小结三：多次构建后，积累的无用镜像" class="headerlink" title="小结三：多次构建后，积累的无用镜像"></a>小结三：多次构建后，积累的无用镜像</h3><p>如下所示，构建多次后，本地会遗留多个名为<none>，tag也是<none>的镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@maven hellojib]# docker images</span><br><span class="line">REPOSITORY               TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">bolingcavalry/hellojib   0.0.1-SNAPSHOT      a9fd91d8ad8c        17 seconds ago       505 MB</span><br><span class="line">&lt;none&gt;                   &lt;none&gt;              a0cadeb9febd        About a minute ago   505 MB</span><br><span class="line">&lt;none&gt;                   &lt;none&gt;              ee5ba19a8016        2 minutes ago        505 MB</span><br><span class="line">&lt;none&gt;                   &lt;none&gt;              ef96fdd4473a        49 years ago         505 MB</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<p>这些都是上一次构建的结果，在经历了新一轮的构建后，其镜像名和tag被新镜像所有，所以自身只能显示名为<none>，tag也是<none>，清理这些镜像的命令是docker image prune，然后根据提示输入”y”，镜像即可被清理：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@maven hellojib]# docker image prune</span><br><span class="line">WARNING! This will remove all dangling images.</span><br><span class="line">Are you sure you want to continue? [y/N] y</span><br><span class="line">Deleted Images:</span><br><span class="line">deleted: sha256:7aa104e20b8a08bac3255f2627ac90f10021c6630370ce7a84ba33f89404b153</span><br><span class="line">deleted: sha256:7dd7376ae00c2df0411bac1eded4b3c79dd1528f5711057fe11a4f4121504486</span><br><span class="line">deleted: sha256:e71ced47e80a7fccfea1710f1e5a257d4e16fc3e96b05616007e15829e71a7b2</span><br><span class="line">deleted: sha256:55bed58453479c2accfc08fabc929aece7d324af0df94335dd46333db9da1d23</span><br><span class="line">deleted: sha256:ef96fdd4473a7ca9d39a50e0feae50131de083cee4f11060ad8bee1bc853b2b5</span><br><span class="line"></span><br><span class="line">Total reclaimed space: 0 B</span><br><span class="line">[root@maven hellojib]# docker images</span><br><span class="line">REPOSITORY               TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">bolingcavalry/hellojib   0.0.1-SNAPSHOT      3afd4165b6b6        About a minute ago   505 MB</span><br><span class="line">1234567891011121314</span><br></pre></td></tr></table></figure>

<h3 id="小结四：提升构建速度"><a href="#小结四：提升构建速度" class="headerlink" title="小结四：提升构建速度"></a>小结四：提升构建速度</h3><p>在使用命令mvn compile jib:dockerBuild构建本地镜像时，每次构建的过程中都会提示以下信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Containerizing application to Docker daemon as bolingcavalry/hellojib:0.0.1-SNAPSHOT...</span><br><span class="line">[INFO] The base image requires auth. Trying again for openjdk:8-jdk-stretch...</span><br><span class="line">[INFO] Executing tasks:</span><br><span class="line">[INFO] [=========                     ] 30.0% complete</span><br><span class="line">[INFO] &gt; pulling base image manifest</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>每次构建都会显示上面的内容，也就是说每次都去远程拉取base镜像的manifest(pulling base image manifest)，这部分时间导致整体构架时间变长，以下是构建结果，可见用了10秒：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Built image to Docker daemon as bolingcavalry/hellojib:0.0.1-SNAPSHOT</span><br><span class="line">[INFO] Executing tasks:</span><br><span class="line">[INFO] [==============================] 100.0% complete</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  10.722 s</span><br><span class="line">[INFO] Finished at: 2019-09-01T08:55:09+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>

<p>首先想到的是执行命令docker pull openjdk:8-jdk-stretch将base镜像下载到本地仓库，再尝试构建，遗憾的是jib依旧会远程获取base镜像的manifest，还是很慢；</p>
<p>如果能避免远程拉取base镜像的manifest，镜像构建速度应该会快一些；基于此推论，优化构建速度的步骤如下：</p>
<ol>
<li>在本机创建registry(docker镜像仓库服务)；</li>
<li>将base镜像openjdk:8-jdk-stretch放入本机registry；</li>
<li>修改pom.xml中base镜像的配置，改为本机registry的镜像；</li>
<li>如此一来，每次都会从本机registry取得base镜像的manifest，不走远程请求响应，构建时间会有提升；</li>
</ol>
<p>接下按照上述步骤进行操作：</p>
<ol>
<li>确认当前电脑的IP地址，我这里是192.168.121.131；</li>
<li>设置本地docker服务支持http：修改docker配置文件：/etc/docker/daemon.json，在json中增加内容”insecure-registries”: [“192.168.121.131:5000”]</li>
<li>重启docker使配置生效：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<ol>
<li>在本地创建一个镜像仓库服务：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name docker-registry -d -p 5000:5000 registry</span><br></pre></td></tr></table></figure>

<ol>
<li>查看本地镜像openjdk:8-jdk-stretch的ID为08ded5f856cc；</li>
<li>用tag命令将本地镜像openjdk:8-jdk-stretch改名，命令如下所示，”192.168.121.131”是当前电脑的IP地址：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag 08ded5f856cc 192.168.121.131:5000/openjdk:8-jdk-stretch</span><br></pre></td></tr></table></figure>

<ol>
<li>再次查看镜像，发现多了个192.168.121.131:5000/openjdk:8u212-jdk-stretch：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@maven hellojib]# docker tag 08ded5f856cc 192.168.121.131:5000/openjdk:8-jdk-stretch</span><br><span class="line">[root@maven hellojib]# docker images</span><br><span class="line">REPOSITORY                     TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">bolingcavalry/hellojib         0.0.1-SNAPSHOT      6601ef5a767d        3 minutes ago       505 MB</span><br><span class="line">192.168.121.131:5000/openjdk   8-jdk-stretch       08ded5f856cc        2 weeks ago         488 MB</span><br><span class="line">docker.io/openjdk              8-jdk-stretch       08ded5f856cc        2 weeks ago         488 MB</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<ol>
<li>将192.168.121.131:5000/openjdk:8-jdk-stretch推送到远程仓库，命令如下所示，由于镜像名前缀是192.168.121.131:5000，镜像会被推送到我们刚刚创建的registry：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.121.131:5000/openjdk:8-jdk-stretch</span><br></pre></td></tr></table></figure>

<ol>
<li>修改java工程的pom.xml，将base镜像由之前的openjdk:8-jdk-stretch改为192.168.121.131:5000/openjdk:8-jdk-stretch</li>
<li>修改java工程的pom.xml，增加allowInsecureRegistries，使jib插件支持http协议连接镜像仓库(安全起见，默认是关闭的)，整个插件的配置信息如下：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--使用jib插件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.cloud.tools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jib-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--from节点用来设置镜像的基础镜像，相当于Docerkfile中的FROM关键字--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">from</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--使用openjdk官方镜像，tag是8-jdk-stretch，表示镜像的操作系统是debian9,装好了jdk8--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">image</span>&gt;</span>192.168.121.131:5000/openjdk:8-jdk-stretch<span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">to</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--镜像名称和tag，使用了mvn内置变量$&#123;project.version&#125;，表示当前工程的version--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">image</span>&gt;</span>bolingcavalry/hellojib:$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--容器相关的属性--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--jvm内存参数--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">jvmFlags</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">jvmFlag</span>&gt;</span>-Xms4g<span class="tag">&lt;/<span class="name">jvmFlag</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">jvmFlag</span>&gt;</span>-Xmx4g<span class="tag">&lt;/<span class="name">jvmFlag</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">jvmFlags</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--要暴露的端口--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">ports</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">ports</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">useCurrentTimestamp</span>&gt;</span>true<span class="tag">&lt;/<span class="name">useCurrentTimestamp</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">allowInsecureRegistries</span>&gt;</span>true<span class="tag">&lt;/<span class="name">allowInsecureRegistries</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>再次执行命令mvn compile jib:dockerBuild，如下所示，时间从之前的10秒缩减到3.9秒：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Built image to Docker daemon as bolingcavalry/hellojib:0.0.1-SNAPSHOT</span><br><span class="line">[INFO] Executing tasks:</span><br><span class="line">[INFO] [==============================] 100.0% complete</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  3.949 s</span><br><span class="line">[INFO] Finished at: 2019-09-01T10:51:50+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>

<p>以上就是通过registry服务提升jib构建速度的方法，在多人开发的时候，registry可以配置为一个公共的，多人都可使用，毕竟pom.xml代码存在公共代码仓库，每个人都去修改成自己的registry的地址是不合适的，一旦提交上去会影响其他人的使用，我们这里的做法是将registry的地址写成host，本地维护好host和IP的映射就可以了。<br>使用本地registry服务，除了提速，在服务器无法连接中央仓库取得openjdk:8-jdk-stretch的manifest时，这种方式能保证构建依旧能够成功；</p>
<h3 id="小结五：将jib与mvn构建的生命周期绑定"><a href="#小结五：将jib与mvn构建的生命周期绑定" class="headerlink" title="小结五：将jib与mvn构建的生命周期绑定"></a>小结五：将jib与mvn构建的生命周期绑定</h3><ol>
<li>前面的实战中构建命令是mvn compile jib:dockerBuild，实际上可以做到仅用mvn compile就完成镜像构建，这是maven插件的通用特性；</li>
<li>修改pom.xml增加executions节点，里面设置compile触发jib:dockerBuild，整个插件的内容如下所示：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.cloud.tools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jib-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--from节点用来设置镜像的基础镜像，相当于Docerkfile中的FROM关键字--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">from</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--使用openjdk官方镜像，tag是8-jdk-stretch，表示镜像的操作系统是debian9,装好了jdk8--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">image</span>&gt;</span>192.168.121.131:5000/openjdk:8-jdk-stretch<span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">to</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--镜像名称和tag，使用了mvn内置变量$&#123;project.version&#125;，表示当前工程的version--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">image</span>&gt;</span>bolingcavalry/hellojib:$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--容器相关的属性--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--jvm内存参数--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">jvmFlags</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">jvmFlag</span>&gt;</span>-Xms4g<span class="tag">&lt;/<span class="name">jvmFlag</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">jvmFlag</span>&gt;</span>-Xmx4g<span class="tag">&lt;/<span class="name">jvmFlag</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">jvmFlags</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--要暴露的端口--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">ports</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">ports</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">useCurrentTimestamp</span>&gt;</span>true<span class="tag">&lt;/<span class="name">useCurrentTimestamp</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">allowInsecureRegistries</span>&gt;</span>true<span class="tag">&lt;/<span class="name">allowInsecureRegistries</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">goal</span>&gt;</span>dockerBuild<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>执行命令mvn compile -DskipTests，如下所示，可以成功构建镜像，与前面的命令结果一致：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[root@maven hellojib]# mvn compile -DskipTests</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] ---------------------&lt; com.bolingcavalry:hellojib &gt;---------------------</span><br><span class="line">[INFO] Building hellojib 0.0.1-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- maven-resources-plugin:3.1.0:resources (default-resources) @ hellojib ---</span><br><span class="line">[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.</span><br><span class="line">[INFO] Copying 1 resource</span><br><span class="line">[INFO] Copying 0 resource</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ hellojib ---</span><br><span class="line">[INFO] Nothing to compile - all classes are up to date</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- jib-maven-plugin:1.3.0:dockerBuild (default) @ hellojib ---</span><br><span class="line">[WARNING] Setting image creation time to current time; your image may not be reproducible.</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] Containerizing application to Docker daemon as bolingcavalry/hellojib:0.0.1-SNAPSHOT...</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] Container entrypoint set to [java, -Xms4g, -Xmx4g, -cp, /app/resources:/app/classes:/app/libs/*, com.bolingcavalry.hellojib.HellojibApplication]</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] Built image to Docker daemon as bolingcavalry/hellojib:0.0.1-SNAPSHOT</span><br><span class="line">[INFO] Executing tasks:</span><br><span class="line">[INFO] [==============================] 100.0% complete</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  3.721 s</span><br><span class="line">[INFO] Finished at: 2019-09-01T11:43:23+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[root@maven hellojib]# docker images</span><br><span class="line">REPOSITORY                     TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">bolingcavalry/hellojib         0.0.1-SNAPSHOT      5e3f62d13a73        35 seconds ago      505 MB</span><br><span class="line">192.168.121.131:5000/openjdk   8-jdk-stretch       08ded5f856cc        2 weeks ago         488 MB</span><br><span class="line">docker.io/openjdk              8-jdk-stretch       08ded5f856cc        2 weeks ago         488 MB</span><br><span class="line">docker.io/registry             latest              f32a97de94e1        5 months ago        25.8 MB</span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738</span><br></pre></td></tr></table></figure>

<h3 id="小结六：父子结构的maven工程如何构建"><a href="#小结六：父子结构的maven工程如何构建" class="headerlink" title="小结六：父子结构的maven工程如何构建"></a>小结六：父子结构的maven工程如何构建</h3><ol>
<li>假设当前maven工程是父子结构的，有两个子工程A和B，其中A是二方库，提供一个jar包，里面是接口类和Bean类，B是springboot应用，并且B的源码中用到了A提供的接口和Bean；</li>
<li>上述父子结构的maven工程是常见的工程结构，此时如果要将B构建成Docker镜像，在B的目录下执行mvn compile jib:dockerBuild显然是不行的，因为没有编译构建A，会导致B的编译失败；</li>
<li>此时最好的做法就是将jib与mvn构建的生命周期绑定，修改B的pom.xml文件，加入executions节点；</li>
<li>在父工程目录下执行mvn compile，此时maven会先编译构建整个工程，然后再将B工程的构建结果制作成镜像；  </li>
</ol>
<h3 id="小结七：jib推送到远程仓库权限的问题"><a href="#小结七：jib推送到远程仓库权限的问题" class="headerlink" title="小结七：jib推送到远程仓库权限的问题"></a>小结七：jib推送到远程仓库权限的问题</h3><h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><p>在39.100.127.235容器镜像服务中创建镜像仓库，开放http端口8009。</p>
<p><img src="C:\Users\Hasee\AppData\Roaming\Typora\typora-user-images\image-20210105105438984.png" alt="image-20210105105438984"></p>
<h5 id="一、设置jdk镜像"><a href="#一、设置jdk镜像" class="headerlink" title="一、设置jdk镜像"></a>一、设置jdk镜像</h5><p>在管理镜像中参考官方给的demo进行设置即可,这里把jdk镜像上传到自己构建的镜像仓库</p>
<p><img src="C:\Users\Hasee\AppData\Roaming\Typora\typora-user-images\image-20210105105619030.png" alt="image-20210105105619030"></p>
<h5 id="二、设置pom-xml"><a href="#二、设置pom-xml" class="headerlink" title="二、设置pom.xml"></a>二、设置pom.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.cloud.tools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jib-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">from</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">image</span>&gt;</span>39.100.127.235:8009/openjdk:8-jdk-alpine<span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">to</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">image</span>&gt;</span>39.100.127.235:8009/individualgrid<span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">tags</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">tag</span>&gt;</span>0.01<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">tags</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">entrypoint</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">shell</span>&gt;</span>bash<span class="tag">&lt;/<span class="name">shell</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>-c<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">arg</span>&gt;</span>chmod +x /entrypoint.sh <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> sync <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> /entrypoint.sh<span class="tag">&lt;/<span class="name">arg</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">entrypoint</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">ports</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">ports</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">useCurrentTimestamp</span>&gt;</span>true<span class="tag">&lt;/<span class="name">useCurrentTimestamp</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">args</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">arg</span>&gt;</span>--spring.profiles.active=prod<span class="tag">&lt;/<span class="name">arg</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">args</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 允许仓库配置的http的仓库私服地址,这个不配置会报错,同时推送到远程仓库时需要加命令行参数 </span></span><br><span class="line"><span class="comment">                -DsendCredentialsOverHttp=true 不加也会报权限问题 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">allowInsecureRegistries</span>&gt;</span>true<span class="tag">&lt;/<span class="name">allowInsecureRegistries</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方法一：配置<code>maven settings.xml</code>文件（推荐）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- pluginGroup | Specifies a further group identifier to use for plugin</span></span><br><span class="line"><span class="comment">        lookup. &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginGroup</span>&gt;</span>com.google.cloud.tools<span class="tag">&lt;/<span class="name">pluginGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--对应容器仓库权限的账号密码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>39.100.127.235:8009<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>grid<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>grid@123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方法二：在pom.xml中添加认证信息（不推荐）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span>&gt;</span>registry.cn-hangzhou.aliyuncs.com/yhhu/jdk8<span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">auth</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>my_username<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>my_password<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">auth</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span>&gt;</span>registry.cn-hangzhou.aliyuncs.com/yhhu/ejile<span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tags</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag</span>&gt;</span>0.01<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tags</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">auth</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>my_username<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>my_password<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">auth</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="三、构建并提交镜像"><a href="#三、构建并提交镜像" class="headerlink" title="三、构建并提交镜像"></a>三、构建并提交镜像</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile jib:build -DsendCredentialsOverHttp=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="扩展使用"><a href="#扩展使用" class="headerlink" title="扩展使用"></a>扩展使用</h3><p>扩展选项提供额外的配置选项为定制镜像生成。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">类型</th>
<th align="left">默认值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>to</code></td>
<td align="left"><code>to</code></td>
<td align="left">Required</td>
<td align="left">配置目标镜像以构建应用程序。</td>
</tr>
<tr>
<td align="left"><code>from</code></td>
<td align="left"><code>from</code></td>
<td align="left">查看<code>from</code></td>
<td align="left">配置基础镜像以构建应用程序的顶部。</td>
</tr>
<tr>
<td align="left"><code>container</code></td>
<td align="left"><code>container</code></td>
<td align="left">查看<code>container</code></td>
<td align="left">配置从镜像中运行的容器。</td>
</tr>
<tr>
<td align="left"><code>allowInsecureRegistries</code></td>
<td align="left">boolean</td>
<td align="left"><code>false</code></td>
<td align="left">如果设置为<code>true</code>，Jib忽略HTTPS证书错误，并可能退回HTTP作为最后的手段。强烈建议将这个参数设置为<code>false</code>，因为HTTP通信是未加密的，并且对于网络上的其他人来说是可见的，并且不安全的HTTPS并不比普通的HTTP好。如果使用自签名证书访问注册表，则将证书添加到Java运行时的可信密钥可能是启用此选项的另一种选择。</td>
</tr>
<tr>
<td align="left"><code>skip</code></td>
<td align="left">boolean</td>
<td align="left"><code>false</code></td>
<td align="left">如果设置为<code>true</code>，则跳过Jib执行（对于多模块项目是有用的）。这也可以通过<code>-Djib.skip</code>跳过命令行选项来指定。</td>
</tr>
<tr>
<td align="left"><code>useOnlyProjectCache</code></td>
<td align="left">boolean</td>
<td align="left"><code>false</code></td>
<td align="left">如果设置为<code>true</code>，Jib不会在不同的Maven项目之间共享缓存。</td>
</tr>
</tbody></table>
<p><code>from</code>是具有以下属性的对象：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">类型</th>
<th align="left">默认值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>image</code></td>
<td align="left">string</td>
<td align="left"><code>gcr.io/distroless/java</code></td>
<td align="left">基础的镜像参考。</td>
</tr>
<tr>
<td align="left"><code>auth</code></td>
<td align="left"><code>auth</code></td>
<td align="left">None</td>
<td align="left">直接指定凭证。</td>
</tr>
<tr>
<td align="left"><code>credHelper</code></td>
<td align="left">string</td>
<td align="left">None</td>
<td align="left">证书助手的后缀，它可以对基础镜像进行身份验证（遵循<code>docker-credential-</code>）。</td>
</tr>
</tbody></table>
<p><code>to</code>是具有以下属性的对象：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">类型</th>
<th align="left">默认值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>image</code></td>
<td align="left">string</td>
<td align="left">Required</td>
<td align="left">目标镜像的参考。这也可以通过<code>-Dimage</code>命令行选项来指定。</td>
</tr>
<tr>
<td align="left"><code>auth</code></td>
<td align="left"><code>auth</code></td>
<td align="left">None</td>
<td align="left">直接指定凭证。</td>
</tr>
<tr>
<td align="left"><code>credHelper</code></td>
<td align="left">string</td>
<td align="left">None</td>
<td align="left">证书助手的后缀，它可以对基础镜像进行身份验证（遵循<code>docker-credential-</code>）。</td>
</tr>
<tr>
<td align="left"><code>tags</code></td>
<td align="left">list</td>
<td align="left">None</td>
<td align="left">额外的标签推向</td>
</tr>
</tbody></table>
<p><code>auth</code>是一个具有以下属性的对象（请参阅使用特定凭据）：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>username</code></td>
<td align="left">string</td>
<td align="left">用户名</td>
</tr>
<tr>
<td align="left"><code>password</code></td>
<td align="left">string</td>
<td align="left">密码</td>
</tr>
</tbody></table>
<p><code>container</code>是具有以下属性的对象：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">类型</th>
<th align="left">默认值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>appRoot</code></td>
<td align="left">string</td>
<td align="left"><code>/app</code></td>
<td align="left">容器上放置应用程序内容的根目录。</td>
</tr>
<tr>
<td align="left"><code>args</code></td>
<td align="left">list</td>
<td align="left">None</td>
<td align="left">默认的主方法参数来运行应用程序。</td>
</tr>
<tr>
<td align="left"><code>entrypoint</code></td>
<td align="left">list</td>
<td align="left">None</td>
<td align="left">启动容器的命令（类似于Docker的入口点指令）。如果设置，则忽略<code>jvmFlags</code>和<code>mainClass</code>。</td>
</tr>
<tr>
<td align="left"><code>environment</code></td>
<td align="left">map</td>
<td align="left">None</td>
<td align="left">键值对，用于设置容器上的环境变量（类似于Docker的Env指令）。</td>
</tr>
<tr>
<td align="left"><code>format</code></td>
<td align="left">string</td>
<td align="left"><code>Docker</code></td>
<td align="left">使用<code>OCI</code>构建OCI容器映像</td>
</tr>
<tr>
<td align="left"><code>jvmFlags</code></td>
<td align="left">list</td>
<td align="left">None</td>
<td align="left">运行应用程序时要传递给JVM的附加标志。</td>
</tr>
<tr>
<td align="left"><code>labels</code></td>
<td align="left">map</td>
<td align="left">None</td>
<td align="left">用于应用镜像元数据的键值对（类似于Docker的标签指令）。</td>
</tr>
<tr>
<td align="left"><code>mainClass</code></td>
<td align="left">string</td>
<td align="left">Inferred*</td>
<td align="left">主要类从应用程序启动。</td>
</tr>
<tr>
<td align="left"><code>ports</code></td>
<td align="left">list</td>
<td align="left">None</td>
<td align="left">容器在运行时暴露的端口（类似于Docker的公开指令）。</td>
</tr>
<tr>
<td align="left"><code>useCurrentTimestamp</code></td>
<td align="left">boolean</td>
<td align="left"><code>false</code></td>
<td align="left">默认情况下，Jib擦除所有时间戳以保证再现性。如果这个参数设置为<code>true</code>，Jib将把镜像的创建时间戳设置为构建时间，这将牺牲可再现性，以便能够容易地判断镜像何时创建。</td>
</tr>
</tbody></table>
<p>您还可以使用<code>connection/read</code>系统属性为注册表交互配置HTTP连接/读取超时，该属性通过命令行以毫秒为单位配置（缺省值是<code>20000</code>；您还可以将其设置为<code>0</code>用于无限超时）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile jib:build -Djib.httpTimeout=3000</span><br></pre></td></tr></table></figure>

<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>在这种配置中，镜像：</p>
<ul>
<li>是从<code>openjdk:alpine</code>的基础上建造的：(pulled from Docker Hub)</li>
<li>被推到<code>localhost:5000/my-image:built-with-jib</code>：<code>localhost:5000/my-image:tag2</code>，<code>localhost:5000/my-image:latest</code></li>
<li>通过调用运行<code>java -Xms512m -Xdebug -Xmy:flag=jib-rules -cp app/libs/*:app/resources:app/classes mypackage.MyApp some args</code></li>
<li>暴露端口1000为TCP（默认），并且端口2000、2001、2002和2003为UDP，</li>
<li>有两个标签(key1:value1 and key2:value2)</li>
<li>构建为OCI格式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;from&gt;</span><br><span class="line">    &lt;image&gt;openjdk:alpine&lt;/image&gt;</span><br><span class="line">  &lt;/from&gt;</span><br><span class="line">  &lt;to&gt;</span><br><span class="line">    &lt;image&gt;localhost:5000/my-image:built-with-jib&lt;/image&gt;</span><br><span class="line">    &lt;credHelper&gt;osxkeychain&lt;/credHelper&gt;</span><br><span class="line">    &lt;tags&gt;</span><br><span class="line">      &lt;tag&gt;tag2&lt;/tag&gt;</span><br><span class="line">      &lt;tag&gt;latest&lt;/tag&gt;</span><br><span class="line">    &lt;/tags&gt;</span><br><span class="line">  &lt;/to&gt;</span><br><span class="line">  &lt;container&gt;</span><br><span class="line">    &lt;jvmFlags&gt;</span><br><span class="line">      &lt;jvmFlag&gt;-Xms512m&lt;/jvmFlag&gt;</span><br><span class="line">      &lt;jvmFlag&gt;-Xdebug&lt;/jvmFlag&gt;</span><br><span class="line">      &lt;jvmFlag&gt;-Xmy:flag=jib-rules&lt;/jvmFlag&gt;</span><br><span class="line">    &lt;/jvmFlags&gt;</span><br><span class="line">    &lt;mainClass&gt;mypackage.MyApp&lt;/mainClass&gt;</span><br><span class="line">    &lt;args&gt;</span><br><span class="line">      &lt;arg&gt;some&lt;/arg&gt;</span><br><span class="line">      &lt;arg&gt;args&lt;/arg&gt;</span><br><span class="line">    &lt;/args&gt;</span><br><span class="line">    &lt;ports&gt;</span><br><span class="line">      &lt;port&gt;1000&lt;/port&gt;</span><br><span class="line">      &lt;port&gt;2000-2003/udp&lt;/port&gt;</span><br><span class="line">    &lt;/ports&gt;</span><br><span class="line">    &lt;labels&gt;</span><br><span class="line">      &lt;key1&gt;value1&lt;/key1&gt;</span><br><span class="line">      &lt;key2&gt;value2&lt;/key2&gt;</span><br><span class="line">    &lt;/labels&gt;</span><br><span class="line">    &lt;format&gt;OCI&lt;/format&gt;</span><br><span class="line">  &lt;/container&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h4 id="在镜像中添加任意文件"><a href="#在镜像中添加任意文件" class="headerlink" title="在镜像中添加任意文件"></a>在镜像中添加任意文件</h4><p><em>注意：这是一个孵化的特点，并可能在未来改变。</em></p>
<p>可以将任意的、非类路径文件添加到<code>src/main/jib</code>目录中，从而将它们添加到镜像中。这将将jib文件夹中的所有文件复制到镜像的根目录，并保持相同的结构（例如，如果文本文件在<code>src/main/jib/dir/hello.txt</code>,然后你的镜像就会包含<code>/dir/hello.txt</code>Jib建成后。</p>
<p>您可以使用<code>pom.xml</code>中的<code>extraDirectory</code>参数配置一个不同的目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;!-- Copies files from &#x27;src/main/custom-extra-dir&#x27; instead of &#x27;src/main/jib&#x27; --&gt;</span><br><span class="line">  &lt;extraDirectory&gt;$&#123;project.basedir&#125;/src/main/custom-extra-dir&lt;/extraDirectory&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h4 id="认证方法"><a href="#认证方法" class="headerlink" title="认证方法"></a>认证方法</h4><p>来自私人注册中心的推/拉需要授权凭证。这些可以使用Docker证书帮助器或在Maven设置中定义。如果不显式地定义凭据，Jib将尝试使用Docker配置中定义的凭据或推断公共凭据助手。</p>
<h4 id="使用Docker凭证帮助器"><a href="#使用Docker凭证帮助器" class="headerlink" title="使用Docker凭证帮助器"></a>使用Docker凭证帮助器</h4><p>Docker证书助手是CLI工具，它处理各种注册表的身份验证。</p>
<p>一些常见的证书帮助者包括：</p>
<ul>
<li>Google Container Registry: <a target="_blank" rel="noopener" href="https://cloud.google.com/container-registry/docs/advanced-authentication#docker_credential_helper">docker-credential-gcr</a></li>
<li>AWS Elastic Container Registry: <a target="_blank" rel="noopener" href="https://github.com/awslabs/amazon-ecr-credential-helper">docker-credential-ecr-login</a></li>
<li>Docker Hub Registry: <a target="_blank" rel="noopener" href="https://github.com/docker/docker-credential-helpers">docker-credential-*</a></li>
</ul>
<p>通过将证书指定为它们各自的镜像的帮助器来配置证书助手。</p>
<p>示例配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;from&gt;</span><br><span class="line">    &lt;image&gt;aws_account_id.dkr.ecr.region.amazonaws.com/my-base-image&lt;/image&gt;</span><br><span class="line">    &lt;credHelper&gt;ecr-login&lt;/credHelper&gt;</span><br><span class="line">  &lt;/from&gt;</span><br><span class="line">  &lt;to&gt;</span><br><span class="line">    &lt;image&gt;gcr.io/my-gcp-project/my-app&lt;/image&gt;</span><br><span class="line">    &lt;credHelper&gt;gcr&lt;/credHelper&gt;</span><br><span class="line">  &lt;/to&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h4 id="使用特定凭证"><a href="#使用特定凭证" class="headerlink" title="使用特定凭证"></a>使用特定凭证</h4><p>您可以在<code>&lt;auth&gt;</code>参数为<code>from</code> and/or <code>to</code>镜像。在下面的示例中，<code>to</code>凭据检索凭据<code>REGISTRY_USERNAME</code>和<code>REGISTRY_PASSWORD</code>环境变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;from&gt;</span><br><span class="line">    &lt;image&gt;aws_account_id.dkr.ecr.region.amazonaws.com/my-base-image&lt;/image&gt;</span><br><span class="line">    &lt;auth&gt;</span><br><span class="line">      &lt;username&gt;my_username&lt;/username&gt;</span><br><span class="line">      &lt;password&gt;my_password&lt;/password&gt;</span><br><span class="line">    &lt;/auth&gt;</span><br><span class="line">  &lt;/from&gt;</span><br><span class="line">  &lt;to&gt;</span><br><span class="line">    &lt;image&gt;gcr.io/my-gcp-project/my-app&lt;/image&gt;</span><br><span class="line">    &lt;auth&gt;</span><br><span class="line">      &lt;username&gt;$&#123;env.REGISTRY_USERNAME&#125;&lt;/username&gt;</span><br><span class="line">      &lt;password&gt;$&#123;env.REGISTRY_PASSWORD&#125;&lt;/password&gt;</span><br><span class="line">    &lt;/auth&gt;</span><br><span class="line">  &lt;/to&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>或者，可以使用下面的系统属性通过命令行指定凭据。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-Djib.from.auth.username</code></td>
<td align="left">基本镜像注册表的用户名。</td>
</tr>
<tr>
<td align="left"><code>-Djib.from.auth.password</code></td>
<td align="left">基本镜像注册表的密码。</td>
</tr>
<tr>
<td align="left"><code>-Djib.to.auth.username</code></td>
<td align="left">目标镜像注册表的用户名。</td>
</tr>
<tr>
<td align="left"><code>-Djib.to.auth.password</code></td>
<td align="left">目标镜像注册表的密码。</td>
</tr>
</tbody></table>
<p>例如：<code>mvn compile jib:build -Djib.to.auth.username=user -Djib.to.auth.password=pass</code></p>
<p><strong>注意：这种身份验证方法只能作为最后的手段，因为用纯文本显示密码是不安全的。</strong></p>
<h4 id="使用Maven设置"><a href="#使用Maven设置" class="headerlink" title="使用Maven设置"></a>使用Maven设置</h4><p>注册表凭据可以添加到您的Maven设置。如果在任何指定的Docker凭证帮助器中找不到凭据，则将使用这些凭据。</p>
<p>如果您考虑在Maven中设置凭据，我们强烈建议使用Maven密码加密。</p>
<p>示例 <code>settings.xml</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;servers&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;server&gt;</span><br><span class="line">      &lt;id&gt;MY_REGISTRY&lt;/id&gt;</span><br><span class="line">      &lt;username&gt;MY_USERNAME&lt;/username&gt;</span><br><span class="line">      &lt;password&gt;&#123;MY_SECRET&#125;&lt;/password&gt;</span><br><span class="line">    &lt;/server&gt;</span><br><span class="line">  &lt;/servers&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>id字段应该是这些凭据所需的注册表服务器。</li>
<li>我们不建议在<code>settings.xml</code>中添加原始密码。</li>
</ul>
<p>以上就是我在近期使用Jib插件时遇到的问题小结，希望这些小技巧可以给您提供一些参考，助您解决问题；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/09/%E5%85%B3%E4%BA%8EJib%E6%8F%92%E4%BB%B6/" data-id="clh04c6dt000oo4rg52830x2n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-访问docker desktop创建的Hyper-v虚拟机DockerDesktopVM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/09/%E8%AE%BF%E9%97%AEdocker%20desktop%E5%88%9B%E5%BB%BA%E7%9A%84Hyper-v%E8%99%9A%E6%8B%9F%E6%9C%BADockerDesktopVM/" class="article-date">
  <time datetime="2021-01-09T05:38:42.495Z" itemprop="datePublished">2021-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​                                     <strong>访问docker desktop创建的Hyper-v虚拟机DockerDesktopVM</strong></p>
<p>平常我们部署kubernetes ,一般都是先安装个linux操作系统,不管是centos或者ubuntu或者其他,都是我们手工操作的.安装好的这个操作系统都开启了SSH,能够远程登录访问. 但是docker desktop 为我们自动创建了一个Hyper-v的虚拟机,你打开虚拟机管理器会看到,这个虚拟机的名字叫做DockerDesktopVM, 从Hyper-v的管理界面无法连接到这个虚拟机,完全就是一个黑箱,甚至你发现这个虚拟机连一个网卡都没配置.实在是太黑暗了.</p>
<p>通过下面的操作可以连接进入.</p>
<p>在你的cmd或者powershell中分别执行下面三行命令.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run --privileged -it -v /var/run/docker.sock:/var/run/docker.sock jongallant/ubuntu-docker-client </span><br><span class="line">docker run --net=host --ipc=host --uts=host --pid=host -it --security-opt=seccomp=unconfined --privileged --rm -v /:/host alpine /bin/sh</span><br><span class="line">chroot /host</span><br></pre></td></tr></table></figure>

<p>这样就连接进来了.</p>
<p>wget <a target="_blank" rel="noopener" href="http://www.google.com/">www.google.com</a> 一下.发现又链接不上了. ping 你的网卡ip又是通的,你的代理也正常,为啥又不行了呢. </p>
<p>先不管它, 在DockerDesktopVM虚拟机中再配置一次代理. 参见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/worldinmyeyes/p/12319405.html">https://www.cnblogs.com/worldinmyeyes/p/12319405.html</a></p>
<p>完成.</p>
<p>uname -a 一下,你会发现,这个linux版本为linuxkit, 是Docker新发布的一个用于为容器构建安全、便携、可移植操作系统的工具包。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/09/%E8%AE%BF%E9%97%AEdocker%20desktop%E5%88%9B%E5%BB%BA%E7%9A%84Hyper-v%E8%99%9A%E6%8B%9F%E6%9C%BADockerDesktopVM/" data-id="clh04c6dx000uo4rggqox8q91" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-springboot 各种配置文件的优先级" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/09/springboot%20%E5%90%84%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/" class="article-date">
  <time datetime="2021-01-09T05:38:42.493Z" itemprop="datePublished">2021-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="springboot-各种配置文件的优先级："><a href="#springboot-各种配置文件的优先级：" class="headerlink" title="springboot 各种配置文件的优先级："></a>springboot 各种配置文件的优先级：</h3><h4 id="1-0-不用配置中心时的优先级："><a href="#1-0-不用配置中心时的优先级：" class="headerlink" title="1.0  不用配置中心时的优先级："></a>1.0  不用配置中心时的优先级：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.1 springboot启动会扫描一下位置的application.properties或者application.yml作为默认的配置文件</span><br><span class="line">工程根目录:./config/</span><br><span class="line">工程根目录：./</span><br><span class="line">classpath:/config/</span><br><span class="line">classpath:/</span><br><span class="line">加载的优先级顺序是从上向下加载，并且所有的文件都会被加载，高优先级的内容会覆盖底优先级的内容，形成互补配置</span><br><span class="line"></span><br><span class="line">也可以通过指定配置spring.config.location来改变默认配置，一般在项目已经打包后，我们可以通过指令 </span><br><span class="line">　　java -jar xxxx.jar --spring.config.location=D:/kawa/application.yml来加载外部的配置</span><br><span class="line">　　</span><br><span class="line">　　                            优先加载带profile</span><br><span class="line"> jar包外部的application-&#123;profile&#125;.propertie或application.yml(带spring.profile)配置文件           </span><br><span class="line"> jar包内部的application-&#123;profile&#125;.propertie或application.yml(带spring.profile)配置文件</span><br><span class="line"></span><br><span class="line">                                再来加载不带profile</span><br><span class="line"> jar包外部的application.propertie或application.yml(不带spring.profile)配置文件</span><br><span class="line"> jar包内部的application.propertie或application.yml(不带spring.profile)配置文件</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h4 id="2-0-Springboot-中application-yml和bootStrap-yml-的加载顺序"><a href="#2-0-Springboot-中application-yml和bootStrap-yml-的加载顺序" class="headerlink" title="2.0  Springboot 中application.yml和bootStrap.yml 的加载顺序"></a>2.0  Springboot 中application.yml和bootStrap.yml 的加载顺序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">1.2 若application.yml 和bootStrap.yml 在同一目录下，则bootStrap.yml 的加载顺序要高于application.yml,即bootStrap.yml  会优先被加载。</span><br><span class="line"></span><br><span class="line">   原理：bootstrap.yml 用于应用程序上下文的引导阶段。</span><br><span class="line"></span><br><span class="line">              bootstrap.yml 由父Spring ApplicationContext加载。</span><br><span class="line"></span><br><span class="line">            •bootstrap.yml 可以理解成系统级别的一些参数配置，这些参数一般是不会变动的。</span><br><span class="line">            •application.yml 可以用来定义应用级别的，如果搭配 spring-cloud-config 使用 application.yml 里面定义的文件可以实现动态替换。</span><br><span class="line"></span><br><span class="line">            使用Spring Cloud Config Server时，应在 bootstrap.yml 中指定：</span><br><span class="line"> 1.3  不同位置的配置文件的加载顺序</span><br><span class="line">   在不指定要被加载文件时，默认的加载顺序：由里向外加载，所以最外层的最后被加载，会覆盖里层的属性（参考官网介绍）</span><br><span class="line"></span><br><span class="line">SpringApplication will load properties from application.properties files in the following locations and add them to the Spring Environment: </span><br><span class="line"></span><br><span class="line">A /config subdirectory of the current directory.    //位于与jar包同级目录下的config文件夹，</span><br><span class="line">The current directory                             //位于与jar包同级目录下</span><br><span class="line">A classpath /config package          //idea 环境下，resource文件夹下的config文件夹</span><br><span class="line">The classpath root                                //idea 环境下，resource文件夹下  （1-&gt;4, 外-&gt;里）</span><br><span class="line">The list is ordered by precedence (properties defined in locations higher in the list override those defined in lower locations).</span><br><span class="line"></span><br><span class="line">3. 可以通过属性指定加载某一文件：</span><br><span class="line"></span><br><span class="line"> java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties</span><br><span class="line">当通过spring.config.location 指定一个配置文件时，配置文件的搜索顺序如下：</span><br><span class="line"></span><br><span class="line">file:./custom-config/</span><br><span class="line">classpath:custom-config/</span><br><span class="line">file:./config/</span><br><span class="line">file:./</span><br><span class="line">classpath:/config/</span><br><span class="line">classpath:/</span><br><span class="line">最下层的优先加载，所以最上层的属性会覆盖下层的属性；</span><br><span class="line"></span><br><span class="line">4. 如果使用spring-cloud-config时，项目内部的resource下有bootstrap.yml文件，并且在bootstrap.yml 里配置spring.application.name, git.url,spring.active.profies. 将项目打成jar包，放到服务器上，与jar包并列的位置，有start.sh脚本， </span><br><span class="line"></span><br><span class="line">a. 在start 脚本里指定了配置文件：spring.config.location=./bootstrap.yml, 则配置文件的加载顺序将为：</span><br><span class="line"></span><br><span class="line">1. cloud-config 仓库里指定的yml 配置；</span><br><span class="line"></span><br><span class="line">2. ./bootstrap.yml</span><br><span class="line"></span><br><span class="line">3. classpath:/bootstrap.yml</span><br><span class="line"></span><br><span class="line">4. 外部application.yml</span><br><span class="line"></span><br><span class="line">5. 内部application.yml</span><br><span class="line"></span><br><span class="line">b. 在start 脚本里指定了配置文件：spring.config.location=./application.yml, 则配置文件的加载顺序将为：</span><br><span class="line"></span><br><span class="line">1. cloud-config 仓库里指定的yml 配置；</span><br><span class="line"></span><br><span class="line">2. ./application.yml</span><br><span class="line"></span><br><span class="line">3.  classpath:/application.yml</span><br><span class="line"></span><br><span class="line">4. ./bootstrap.yml</span><br><span class="line"></span><br><span class="line">5. classpath:/bootstrap.yml</span><br><span class="line"></span><br><span class="line">所以，不管是jar包内还是jar运行的同级目录下，只要包含bootstrap.yml ，且为云配置，则云配置文件会覆盖其他配置文件；</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/09/springboot%20%E5%90%84%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/" data-id="clh04c6dr000lo4rgc2581vw9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mvn插件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/09/mvn%E6%8F%92%E4%BB%B6/" class="article-date">
  <time datetime="2021-01-09T05:38:42.491Z" itemprop="datePublished">2021-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​                                                                    <strong>mvn插件</strong></p>
<p>FAQ</p>
<p>1: 没有显式指定-P参数，profile webpack也会运行？</p>
<p>解决思路：当初以为是绑定了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;phase&gt;generate-resources&lt;/phase&gt;</span><br></pre></td></tr></table></figure>

<p>mvn的时期，会主动运行，最后发现把这个注释掉还是会运行，经过仔细排查，发现是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;activation&gt;</span><br><span class="line">    &lt;file&gt;</span><br><span class="line">        &lt;missing&gt;$&#123;basedir&#125;/target/classes/static/app/main.bundle.js&lt;/missing&gt;</span><br><span class="line">    &lt;/file&gt;</span><br><span class="line">&lt;/activation&gt;</span><br></pre></td></tr></table></figure>

<p>在作妖，总结：还是对maven插件不是太了解</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/09/mvn%E6%8F%92%E4%BB%B6/" data-id="clh04c6dq000ko4rg5hvj4atw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Maven私服Nexus3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/09/Maven%E7%A7%81%E6%9C%8DNexus3/" class="article-date">
  <time datetime="2021-01-09T05:38:42.489Z" itemprop="datePublished">2021-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Maven私服Nexus3-x环境构建操作记录"><a href="#Maven私服Nexus3-x环境构建操作记录" class="headerlink" title="Maven私服Nexus3.x环境构建操作记录"></a>Maven私服Nexus3.x环境构建操作记录</h1><h4 id="一、Maven介绍"><a href="#一、Maven介绍" class="headerlink" title="一、Maven介绍"></a><strong>一、Maven介绍</strong></h4><p>Apache Maven是一个创新的软件项目管理和综合工具。<br>Maven提供了一个基于项目对象模型（POM）文件的新概念来管理项目的构建，可以从一个中心资料片管理项目构建，报告和文件。<br>Maven最强大的功能就是能够自动下载项目依赖库。<br>Maven提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven使用标准的目录结构和默认构建生命周期。<br>在多个开发团队环境时，Maven可以设置按标准在非常短的时间里完成配置工作。由于大部分项目的设置都很简单，并且可重复使用，Maven让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置。<br>Maven项目的结构和内容在一个XML文件中声明，pom.xml 项目对象模型（POM），这是整个Maven系统的基本单元。</p>
<p>Maven提供了开发人员的方式来管理：<br>1）Builds<br>2）Documentation<br>3）Reporting<br>4）Dependencies<br>5）SCMs<br>6）Releases<br>7）Distribution<br>8）mailing list<br>概括地说，Maven简化和标准化项目建设过程。处理编译，分配，文档，团队协作和其他任务的无缝连接。<br>Maven增加可重用性并负责建立相关的任务。<br>Maven最初设计，是以简化Jakarta Turbine项目的建设。在几个项目，每个项目包含了不同的Ant构建文件。 JAR检查到CVS。<br>Apache组织开发Maven可以建立多个项目，发布项目信息，项目部署，在几个项目中JAR文件提供团队合作和帮助。</p>
<p>Maven主要目标是提供给开发人员：<br>1）项目是可重复使用，易维护，更容易理解的一个综合模型。<br>2）插件或交互的工具，这种声明性的模式。</p>
<h4 id="二、私服介绍"><a href="#二、私服介绍" class="headerlink" title="二、私服介绍"></a><strong>二、私服介绍</strong></h4><p>私服是指私有服务器，是架设在局域网的一种特殊的远程仓库，目的是代理远程仓库及部署第三方构建。有了私服之后，当 Maven 需要下载构件时，直接请求私服，私服上存在则下载到本地仓库；否则，私服请求外部的远程仓库，将构件下载到私服，再提供给本地仓库下载。</p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161220162726057-620806393.png" alt="img"></p>
<h4 id="三、Nexus介绍"><a href="#三、Nexus介绍" class="headerlink" title="三、Nexus介绍"></a><strong>三、Nexus介绍</strong></h4><p>Nexus是一个强大的Maven仓库管理器，它极大地简化了本地内部仓库的维护和外部仓库的访问。<br>如果使用了公共的Maven仓库服务器，可以从Maven中央仓库下载所需要的构件（Artifact），但这通常不是一个好的做法。<br>正常做法是在本地架设一个Maven仓库服务器，即利用Nexus私服可以只在一个地方就能够完全控制访问和部署在你所维护仓库中的每个Artifact。<br>Nexus在代理远程仓库的同时维护本地仓库，以降低中央仓库的负荷,节省外网带宽和时间，Nexus私服就可以满足这样的需要。<br>Nexus是一套“开箱即用”的系统不需要数据库，它使用文件系统加Lucene来组织数据。<br>Nexus使用ExtJS来开发界面，利用Restlet来提供完整的REST APIs，通过m2eclipse与Eclipse集成使用。<br>Nexus支持WebDAV与LDAP安全身份认证。<br>Nexus还提供了强大的仓库管理功能，构件搜索功能，它基于REST，友好的UI是一个extjs的REST客户端，它占用较少的内存，基于简单文件系统而非数据库。</p>
<p>为什么要构建Nexus私服？<br>如果没有Nexus私服，我们所需的所有构件都需要通过maven的中央仓库和第三方的Maven仓库下载到本地，而一个团队中的所有人都重复的从maven仓库下载构件无疑加大了仓库的负载和浪费了外网带宽，如果网速慢的话，还会影响项目的进程。很多情况下项目的开发都是在内网进行的，连接不到maven仓库怎么办呢？开发的公共构件怎么让其它项目使用？这个时候我们不得不为自己的团队搭建属于自己的maven私服，这样既节省了网络带宽也会加速项目搭建的进程，当然前提条件就是你的私服中拥有项目所需的所有构件。</p>
<p>总之，在本地构建nexus私服的好处有：<br>1）加速构建；<br>2）节省带宽；<br>3）节省中央maven仓库的带宽；<br>4）稳定（应付一旦中央服务器出问题的情况）；<br>5）控制和审计；<br>6）能够部署第三方构件；<br>7）可以建立本地内部仓库；<br>8）可以建立公共仓库<br>这些优点使得Nexus日趋成为最流行的Maven仓库管理器。</p>
<h4 id="四、Maven的安装"><a href="#四、Maven的安装" class="headerlink" title="四、Maven的安装"></a><strong>四、Maven的安装</strong></h4><p>下载地址：<a target="_blank" rel="noopener" href="http://maven.apache.org/download.cgi">http://maven.apache.org/download.cgi</a><br>提前在服务器上安装jdk环境（参考：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/kevingrace/p/5870814.html">Centos中yum方式安装java</a>）<br>[root@master-node ~]# cd /usr/local/src/<br>[root@master-node src]# wget <a target="_blank" rel="noopener" href="http://mirrors.hust.edu.cn/apache/maven/maven-3/3.3.9/binaries/apache-maven-3.3.9-bin.tar.gz">http://mirrors.hust.edu.cn/apache/maven/maven-3/3.3.9/binaries/apache-maven-3.3.9-bin.tar.gz</a><br>[root@master-node src]# tar -zvxf apache-maven-3.3.9-bin.tar.gz<br>[root@master-node src]# mv apache-maven-3.3.9 /usr/local/maven</p>
<p>接着配置系统环境变量，在/etc/profile文件底部添加如下内容：<br>[root@master-node src]# java -version<br>openjdk version “1.8.0_111”<br>OpenJDK Runtime Environment (build 1.8.0_111-b15)<br>OpenJDK 64-Bit Server VM (build 25.111-b15, mixed mode)<br>[root@master-node src]# vim /etc/profile<br>…..<br>export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk                 //java的环境变量设置<br>export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar<br>export PATH=$PATH:$JAVA_HOME/bin</p>
<p>export MAVEN_HOME=/usr/local/maven                         //maven的环境变量设置<br>export PATH=$PATH:$MAVEN_HOME/bin<br>[root@master-node src]# source /etc/profile</p>
<p>最后验证是否安装成功，出现如下信息，说明安装成功<br>[root@master-node src]# mvn –version          # 最好按照java jdk<br>Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)<br>Maven home: /usr/local/maven<br>Java version: 1.8.0_111, vendor: Oracle Corporation<br>Java home: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.111-2.b15.el7_3.x86_64/jre<br>Default locale: en_US, platform encoding: UTF-8<br>OS name: “linux”, version: “3.10.0-327.el7.x86_64”, arch: “amd64”, family: “unix”</p>
<h4 id="五、Nexus安装"><a href="#五、Nexus安装" class="headerlink" title="五、Nexus安装"></a><strong>五、Nexus安装</strong></h4><p>Nexus的安装有两种实现方式：<br>1）war包安装方式<br>下载地址：<a target="_blank" rel="noopener" href="https://sonatype-download.global.ssl.fastly.net/nexus/oss/nexus-2.14.2-01.war">https://sonatype-download.global.ssl.fastly.net/nexus/oss/nexus-2.14.2-01.war</a><br>直接将war包放在tomcat的根目录下，启动tomcat就可以用了</p>
<p>2）源码安装方式（之前在用的是2.14.4版本，这里是新版本）<br>下载地址：<a target="_blank" rel="noopener" href="https://www.sonatype.com/download-oss-sonatype">https://www.sonatype.com/download-oss-sonatype</a>      （云盘下载：<a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1miKFm5a%EF%BC%89">http://pan.baidu.com/s/1miKFm5a）</a><br>[root@master-node ~]# cd /usr/local/src/<br>[root@master-node src]# wget <a target="_blank" rel="noopener" href="https://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.2.0-01-unix.tar.gz">https://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.2.0-01-unix.tar.gz</a><br>[root@master-node src]# tar -zvxf nexus-3.2.0-01-unix.tar.gz<br>[root@master-node src]# mv nexus-3.2.0-01 /usr/local/nexus</p>
<p>启动nexus（默认端口是8081）<br>[root@master-node src]# /usr/local/nexus/bin/nexus<br>WARNING: ************************************************************<br>WARNING: Detected execution as “root” user. This is NOT recommended!<br>WARNING: ************************************************************<br>Usage: /usr/local/nexus/bin/nexus {start|stop|run|run-redirect|status|restart|force-reload}<br>[root@master-node src]# /usr/local/nexus/bin/nexus start<br>WARNING: ************************************************************<br>WARNING: Detected execution as “root” user. This is NOT recommended!<br>WARNING: ************************************************************<br>Starting nexus<br>上面在启动过程中出现告警：不推荐使用root用户启动。这个告警不影响nexus的正常访问和使用。<br>去掉上面WARNING的办法：<br>[root@master-node src]# vim /etc/profile<br>……<br>export RUN_AS_USER=root<br>[root@master-node src]# source /etc/profile<br>[root@master-node src]#                               //nexus服务启动成功后，需要稍等一段时间，8081端口才起来<br>COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME<br>java 1486 root 859u IPv4 23504303 0t0 TCP *:tproxy (LISTEN)</p>
<p>在部署机上的iptables里打开8081端口<br>[root@master-node src]# vim /etc/sysconfig/iptables<br>….<br>-A INPUT -p tcp -m state –state NEW -m tcp –dport 8081 -j ACCEPT<br>[root@master-node src]# /etc/init.d/iptables restart</p>
<p>访问nexus，即<a target="_blank" rel="noopener" href="http://39.100.127.235:8081/">http://39.100.127.235:8081</a> （如果出现404，就访问<a target="_blank" rel="noopener" href="http://39.100.127.235:8081/nexus%EF%BC%89">http://39.100.127.235:8081/nexus）</a></p>
<p>出现上述页面，说明配置nexus成功！<br>点击右上角“Log in”，<br>输入默认用户名(admin)和默认密码（admin123）登录</p>
<p>可以点击上面的“设置”图标，在“设置”里可以添加用户、角色，对接LDAP等的设置，如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161220154712776-67407111.png" alt="img"></p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161220154756276-1502291718.png" alt="img"></p>
<p>可以在“管理”里查看nexus的系统信息</p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161220160738011-558914286.png" alt="img"></p>
<h4 id="六、Nexus说明"><a href="#六、Nexus说明" class="headerlink" title="六、Nexus说明"></a><strong>六、Nexus说明</strong></h4><p>1.component name的一些说明：<br>  1）maven-central：maven中央库，默认从<a target="_blank" rel="noopener" href="https://repo1.maven.org/maven2/%E6%8B%89%E5%8F%96jar">https://repo1.maven.org/maven2/拉取jar</a><br>  2）maven-releases：私库发行版jar<br>  3）maven-snapshots：私库快照（调试版本）jar<br>  4）maven-public：仓库分组，把上面三个仓库组合在一起对外提供服务，在本地maven基础配置settings.xml中使用。<br>2.Nexus默认的仓库类型有以下四种：<br>  1）group(仓库组类型)：又叫组仓库，用于方便开发人员自己设定的仓库；<br>  2）hosted(宿主类型)：内部项目的发布仓库（内部开发人员，发布上去存放的仓库）；<br>  3）proxy(代理类型)：从远程中央仓库中寻找数据的仓库（可以点击对应的仓库的Configuration页签下Remote Storage Location属性的值即被代理的远程仓库的路径）；<br>  4）virtual(虚拟类型)：虚拟仓库（这个基本用不到，重点关注上面三个仓库的使用）；<br>3.Policy(策略):表示该仓库为发布(Release)版本仓库还是快照(Snapshot)版本仓库；<br>4.Public Repositories下的仓库<br>  1）3rd party: 无法从公共仓库获得的第三方发布版本的构件仓库，即第三方依赖的仓库，这个数据通常是由内部人员自行下载之后发布上去；<br>  2）Apache Snapshots: 用了代理ApacheMaven仓库快照版本的构件仓库<br>  3）Central: 用来代理maven中央仓库中发布版本构件的仓库<br>  4）Central M1 shadow: 用于提供中央仓库中M1格式的发布版本的构件镜像仓库<br>  5）Codehaus Snapshots: 用来代理CodehausMaven 仓库的快照版本构件的仓库<br>  6）Releases: 内部的模块中release模块的发布仓库，用来部署管理内部的发布版本构件的宿主类型仓库；release是发布版本；<br>  7）Snapshots:发布内部的SNAPSHOT模块的仓库，用来部署管理内部的快照版本构件的宿主类型仓库；snapshots是快照版本，也就是不稳定版本<br>所以自定义构建的仓库组代理仓库的顺序为：Releases，Snapshots，3rd party，Central。也可以使用oschina放到Central前面，下载包会更快。<br>5.Nexus默认的端口是8081，可以在etc/nexus-default.properties配置中修改。<br>6.Nexus默认的用户名密码是admin/admin123<br>7.当遇到奇怪问题时，重启nexus，重启后web界面要1分钟左右后才能访问。<br>8.Nexus的工作目录是sonatype-work（路径一般在nexus同级目录下）<br>[root@master-node local]# pwd<br>/usr/local<br>[root@master-node local]# ls nexus/<br>bin deploy etc lib LICENSE.txt NOTICE.txt public system<br>[root@master-node local]# ls sonatype-work/<br>nexus3<br>[root@master-node local]# ls sonatype-work/nexus3/<br>backup blobs cache db elasticsearch etc generated-bundles health-check instances keystores lock log orient port tmp</p>
<p><strong>Nexus仓库分类的概念</strong><br>1）Maven可直接从宿主仓库下载构件,也可以从代理仓库下载构件,而代理仓库间接的从远程仓库下载并缓存构件<br>2）为了方便,Maven可以从仓库组下载构件,而仓库组并没有时间的内容(下图中用虚线表示,它会转向包含的宿主仓库或者代理仓库获得实际构件的内容).</p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161220164452667-1588016524.png" alt="img"></p>
<p><strong>Nexus的web界面功能介绍</strong></p>
<p><strong>1.Browse Server Content</strong></p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161221105344026-1095529496.png" alt="img"></p>
<p>1.1  Search<br>这个就是类似Maven仓库上的搜索功能，就是从私服上查找是否有哪些包。<br>注意：<br>1）在Search这级是支持模糊搜索的，如图所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161221105547167-2017264888.png" alt="img"></p>
<p>2）如果进入具体的目录，好像不支持模糊搜索，如图所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161221105634245-19314456.png" alt="img"></p>
<p>1.2  Browse</p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161221105808261-1531078817.png" alt="img"></p>
<p>1）Assets<br>这是能看到所有的资源，包含Jar，已经对Jar的一些描述信息。<br>2）Components<br>这里只能看到Jar包。</p>
<p><strong>2.Server Adminstration And configuration</strong></p>
<p>看到这个选项的前提是要进行登录的，如上面已经介绍登陆方法，右上角点击“Sign In”的登录按钮，输入admin/admin123,登录成功之后，即可看到此功能，如图所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161221110207479-318443915.png" alt="img"></p>
<p>2.1 Blob Stores<br>文件存储的地方，创建一个目录的话，对应文件系统的一个目录，如图所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161221110317932-1418604671.png" alt="img"></p>
<p>2.2 Repositories</p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161221110524073-153249455.png" alt="img"></p>
<p>1）Proxy<br>这里就是代理的意思，代理中央Maven仓库，当PC访问中央库的时候，先通过Proxy下载到Nexus仓库，然后再从Nexus仓库下载到PC本地。<br>这样的优势只要其中一个人从中央库下来了，以后大家都是从Nexus私服上进行下来，私服一般部署在内网，这样大大节约的宽带。<br>创建Proxy的具体步骤<br>1–点击“Create Repositories”按钮</p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161221110640089-1389328954.png" alt="img"></p>
<p>2–选择要创建的类型</p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161221110758542-1042948386.png" alt="img"></p>
<p>3–填写详细信息<br>Name：就是为代理起个名字<br>Remote Storage: 代理的地址，Maven的地址为: <a target="_blank" rel="noopener" href="https://repo1.maven.org/maven2/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%9C%B0%E5%9D%80%E4%B8%BA%EF%BC%9Ahttps://maven.aliyun.com/repository/public">https://repo1.maven.org/maven2/阿里云的地址为：https://maven.aliyun.com/repository/public</a><br>Blob Store: 选择代理下载包的存放路径</p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161221111233651-1321037653.png" alt="img"></p>
<p>2）Hosted<br>Hosted是宿主机的意思，就是怎么把第三方的Jar放到私服上。<br>Hosted有三种方式，Releases、SNAPSHOT、Mixed<br>Releases: 一般是已经发布的Jar包<br>Snapshot: 未发布的版本<br>Mixed：混合的<br>Hosted的创建和Proxy是一致的，具体步骤和上面基本一致。如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161221111325104-723208432.png" alt="img"></p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161221111344573-1949446719.png" alt="img"></p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161221111419870-2005652543.png" alt="img"></p>
<p><strong>注意事项：</strong><br>Deployment Pollcy: 需要把策略改成“Allow redeploy”。</p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161221111455589-1303191395.png" alt="img"></p>
<p>3）Group<br>能把两个仓库合成一个仓库来使用，目前没使用过，所以没做详细的研究。</p>
<p>2.3 Security<br>这里主要是用户、角色、权限的配置（上面已经提到了在这里添加用户和角色等）</p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161221111747745-1991046629.png" alt="img"></p>
<p>2.4 Support<br>包含日志及数据分析。</p>
<p><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161221111920261-269936853.png" alt="img"></p>
<p>2.5 System<br>主要是邮件服务器，调度的设置地方<br>这部分主要讲怎么和Maven做集成,集成的方式主要分以下种情况：代理中央仓库、Snapshot包的管理、Release包的管理、第三方Jar上传到Nexus上。</p>
<p><strong>代理中央仓库</strong><br>只要在PMO文件中配置私服的地址（比如<a href="http://39.100.127.235:8081）即可，配置如下：">http://39.100.127.235:8081）即可，配置如下：</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories&gt;   </span><br><span class="line"> &lt;repository&gt;     </span><br><span class="line">  &lt;id&gt;grid-repos-group&lt;/id&gt;     </span><br><span class="line">  &lt;name&gt;grid repos group&lt;/name&gt;     </span><br><span class="line">  &lt;url&gt;http://39.100.127.235:8081/repository/grid-repos-group/&lt;/url&gt;     </span><br><span class="line"> &lt;snapshots&gt;       </span><br><span class="line">  &lt;enabled&gt;true&lt;/enabled&gt;     </span><br><span class="line"> &lt;/snapshots&gt;</span><br><span class="line"> &lt;releases&gt;       </span><br><span class="line">  &lt;enabled&gt;true&lt;/enabled&gt; </span><br><span class="line"> &lt;/releases&gt;   </span><br><span class="line"> &lt;/repository&gt; </span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Snapshot包的管理</strong><br>1）修改Maven的settings.xml文件，加入认证机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;servers&gt;</span><br><span class="line">    &lt;server&gt;</span><br><span class="line">      &lt;id&gt;grid-repos-group&lt;/id&gt;  &lt;!--对应pom.xml的id=grid-repos-group的仓库--&gt;</span><br><span class="line">      &lt;username&gt;grid&lt;/username&gt;</span><br><span class="line">      &lt;password&gt;grid@123&lt;/password&gt;</span><br><span class="line">    &lt;/server&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 发布包到私服的权限配置 --&gt;</span><br><span class="line">	&lt;server&gt;</span><br><span class="line">      &lt;id&gt;grid-hosted-release&lt;/id&gt;  &lt;!--对应pom.xml的id=grid-hosted-release的仓库--&gt;</span><br><span class="line">      &lt;username&gt;grid&lt;/username&gt;</span><br><span class="line">      &lt;password&gt;grid@123&lt;/password&gt;</span><br><span class="line">    &lt;/server&gt;</span><br><span class="line">     &lt;server&gt;</span><br><span class="line">      &lt;id&gt;grid-hosted-snapshot&lt;/id&gt; &lt;!--对应pom.xml中id=grid-hosted-snapshot的仓库--&gt;</span><br><span class="line">      &lt;username&gt;grid&lt;/username&gt;</span><br><span class="line">      &lt;password&gt;grid@123&lt;/password&gt;</span><br><span class="line">    &lt;/server&gt;</span><br><span class="line">  &lt;/servers&gt;</span><br></pre></td></tr></table></figure>

<p>2）修改工程的Pom文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;distributionManagement&gt;</span><br><span class="line">        &lt;snapshotRepository&gt;</span><br><span class="line">            &lt;id&gt;grid-hosted-snapshot&lt;/id&gt;</span><br><span class="line">            &lt;!--指向仓库类型为host(宿主仓库）的储存类型为Snapshot的仓库--&gt;</span><br><span class="line">            &lt;url&gt;http://39.100.127.235:8081/repository/grid-hosted-snapshot/&lt;/url&gt;</span><br><span class="line">        &lt;/snapshotRepository&gt;</span><br><span class="line">    &lt;/distributionManagement&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项:</strong></p>
<p><img src="C:\Users\Hasee\AppData\Roaming\Typora\typora-user-images\image-20201228162916276.png" alt="image-20201228162916276"></p>
<p>上面修改的Pom文件如截图中的名字要跟/usr/local/maven/conf/settings.xml文件中的名字一定要对应上。</p>
<p>3）上传到Nexus上</p>
<p>1–项目编译成的jar是Snapshot(POM文件的头部)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;artifactId&gt;grid-app-web&lt;/artifactId&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br></pre></td></tr></table></figure>

<p>2–使用mvn deploy命令运行即可（运行结果在此略过）</p>
<p>3–因为Snapshot是快照版本，默认他每次会把Jar加一个时间戳，做为历史备份版本。</p>
<p><strong>Releases包的管理</strong></p>
<p>1）与Snapshot大同小异，只是上传到私服上的Jar包不会自动带时间戳<br>2）与Snapshot配置不同的地方，就是工程的POM文件，加入repository配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;distributionManagement&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;!--id的名字可以任意取，但是在setting文件中的属性&lt;server&gt;的ID与这里一致--&gt;</span><br><span class="line">            &lt;id&gt;grid-hosted-release&lt;/id&gt;</span><br><span class="line">            &lt;!--指向仓库类型为host(宿主仓库）的储存类型为Release的仓库--&gt;</span><br><span class="line">            &lt;url&gt;http://39.100.127.235:8081/repository/grid-hosted-release/&lt;/url&gt;</span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">&lt;/distributionManagement&gt;</span><br></pre></td></tr></table></figure>

<p>3）打包的时候需要把Snapshot去掉</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;artifactId&gt;grid-app-web&lt;/artifactId&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">&lt;version&gt;0.0.1&lt;/version&gt;</span><br></pre></td></tr></table></figure>

<h5 id="第三方Jar上传到Nexus"><a href="#第三方Jar上传到Nexus" class="headerlink" title="第三方Jar上传到Nexus"></a><strong>第三方Jar上传到Nexus</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master-node src]# mvn deploy:deploy-file -DgroupId=com.app.grid -DartifactId=grid-app-web -Dversion=0.0.1 -Dpackaging=jar -Dfile=G:\jar\grid-app-web.jar -Durl=http://39.100.127.235:8081/repository/grid-hosted-release/ -DrepositoryId=grid-hosted-release</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong><br>-DrepositoryId=grid-hosted-release对应的就是Maven中settings.xml的认证配的名字。</p>
<h5 id="maven安装本地jar包到本地仓库"><a href="#maven安装本地jar包到本地仓库" class="headerlink" title="maven安装本地jar包到本地仓库"></a><strong>maven安装本地jar包到本地仓库</strong></h5><p>Maven 安装 JAR 包到本地仓库的命令是： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -Dfile=jar包的位置 -DgroupId=上面的groupId -DartifactId=上面的artifactId -Dversion=上面的version -Dpackaging=jar</span><br></pre></td></tr></table></figure>

<p>原则上Maven的设计是不需要这么做的，因为pom.xml中依赖的jar包会自动实现从中央仓库下载到本地仓库。</p>
<p>但也有特殊情况。</p>
<p>例：spring的jdbc ：ojdbc6.jar</p>
<p>　　1.首先将本地jar包放在D:\IDEA下</p>
<p>　　2.配置pom.xml（不能够自动下载jar包）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.oracle&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>　　3.命令行执行如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -Dfile=D:\IDEA\ojdbc6.jar -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=6 -Dpackaging=jar</span><br></pre></td></tr></table></figure>

<p>　　运行成功如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/1602834/201905/1602834-20190531143525889-1776233827.png" alt="img"></p>
<h4 id="七、Nexus库被删除的恢复方法"><a href="#七、Nexus库被删除的恢复方法" class="headerlink" title="七、Nexus库被删除的恢复方法"></a><strong>七、Nexus库被删除的恢复方法</strong></h4><p>在整理Maven私服的时候，不小心把Release库删掉了。瞬间冒出冷汗来了！脑子里闪过第一个办法就是看是否有回收站，恰好在Nexus UI中看到了一个叫Trash…的功能。可是我点击后发现只有Empty Trash的功能，这要按下去还得了啊。</p>
<p><img src="https://img2018.cnblogs.com/blog/907596/201907/907596-20190723120600389-1969163511.png" alt="img"></p>
<p>最后在Sonatype Nexus官方搜索到一篇文章，原文如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">When you delete a repository from the Nexus UI, nexus will remove the repository from any ``groups` `it belongs too and move the repository contents to``it&#x27;s trash folder. Sometimes you will want to restore this repository back into service.``To restore a deleted repository with ``id` `of ``&#x27;releases&#x27;``:&lt;br&gt;``1. ``mv` `sonatype-work``/nexus/trash/releases` `sonatype-work``/storage` `so that you end up with sonatype-work``/storage/releases``2. Recreate the repository with the same repository ``id` `&#x27;releases&#x27;` `using the repositories tab user interface.``3. Add the repository to any ``groups` `that it was ``in` `before.``The act of creating the repository ``in` `the UI will force a reindex of the previous repository storage contents.</span><br></pre></td></tr></table></figure>

<p>幸好！找到了被删除文件恢复的办法。最后按照官方所提供的办法成功地恢复了被删Release库下所有的数据。操作步骤如下：</p>
<p><strong>1）首先找到sonatype-work/nexus/trash 下找到你删除的库，并保存到其他地方;</strong></p>
<p><img src="https://img2018.cnblogs.com/blog/907596/201907/907596-20190723120741962-309638239.png" alt="img"></p>
<p><strong>2）然后通过nexus控制台点击Add，选择Hosted Repository，然后输入被删除的Repository信息；</strong></p>
<p><img src="https://img2018.cnblogs.com/blog/907596/201907/907596-20190723121116376-614786369.png" alt="img"></p>
<p><strong>3）把刚才保存的库文件copy到指定的sonatype-work/nexus/storage/[releases]下即可;</strong><br><strong>4）点击列表中的Public Repositories，然后在下方的Configuration标签下将Releases添加到Ordered Group Repositories中;</strong></p>
<p><img src="https://img2018.cnblogs.com/blog/907596/201907/907596-20190723121124448-1899144020.png" alt="img"></p>
<p><strong>5）最后Save保存就可以了。</strong></p>
<h4 id="八、通过nexus构建docker仓库"><a href="#八、通过nexus构建docker仓库" class="headerlink" title="八、通过nexus构建docker仓库"></a><strong>八、通过nexus构建docker仓库</strong></h4><p><img src="C:\Users\Hasee\AppData\Roaming\Typora\typora-user-images\image-20210109115256923.png" alt="image-20210109115256923"></p>
<p><img src="C:\Users\Hasee\AppData\Roaming\Typora\typora-user-images\image-20210109115355394.png" alt="image-20210109115355394"></p>
<p><font color="red">docker仓库的http端口，这个很重要，docker仓库的访问就是通过这个端口来访问的，和maven的有差别</font></p>
<p><strong>接下来,我们在主机上登录这个仓库</strong></p>
<p>用户名密码是 我们启动服务的时候的重置的密码</p>
<p><img src="https://img-blog.csdnimg.cn/20190909150821872.png" alt="img"></p>
<p><strong>查看你现在的拥有的镜像</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190909150950345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5tdXlp,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>我现在用nginx 举例子,上传这个镜像到我们刚刚搭建的私服上去:步骤如下</strong></p>
<p><strong>修改tag</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190909151205236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5tdXlp,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>push 该镜像</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190909151326823.png" alt="img"></p>
<p><strong>执行完成,去私服查看一下</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190909151433391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5tdXlp,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>上传是完成了,我们在试一下pull</strong></p>
<p><strong>为了测试,我先把我刚刚tag 的镜像删除</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190909151612940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5tdXlp,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>目前没有192.168.134.131:5000/nginx_v1 这个镜像了,现在从私服拉取</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190909151738173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5tdXlp,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>从私服的创建到上传,到下载,已经完成了,那么我们校验一下我们拉取下来的这个nginx 可用不可用?(其实多此一举,算了还是试试吧,哈哈)</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190909152103864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5tdXlp,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>启动成功,访问页面</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190909152133765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5tdXlp,size_16,color_FFFFFF,t_70" alt="img"></p>
<h4 id="九、将本地库批量导入到Nexus3-x上（Maven私服）"><a href="#九、将本地库批量导入到Nexus3-x上（Maven私服）" class="headerlink" title="九、将本地库批量导入到Nexus3.x上（Maven私服）"></a>九、将本地库批量导入到Nexus3.x上（Maven私服）</h4><h5 id="1，问题描述"><a href="#1，问题描述" class="headerlink" title="1，问题描述"></a>1，问题描述</h5><p>（1）由于公司内网的 <strong>Nexus</strong> 私服仓库不能联网，不过本地仓库已经有很多的 <strong>maven</strong> 的 <strong>jar</strong> 包了，便想将其从本地仓库导入到 <strong>Nexus</strong> 私服中。</p>
<p>（2）<strong>Nexus2.x</strong> 批量导入本地库是十分容易的，只需将库文件夹复制到对应 <strong>nexus</strong> 库下面，去网页刷新一下索引就OK了。在 <strong>Nexus3.x</strong> 中，我们没法这么操作了，但是我们可以使用 <strong>shell</strong> 脚本，批量导入 <strong>Nexus3.x</strong>。</p>
<h5 id="2，操作步骤"><a href="#2，操作步骤" class="headerlink" title="2，操作步骤"></a>2，操作步骤</h5><p>（1）首先访问 <strong>Nexus</strong> 页面，登录后点击“<strong>Create repository</strong>”按钮新建一个仓库。</p>
<p><a target="_blank" rel="noopener" href="https://www.hangge.com/blog/cache/detail_2910.html#"><img src="https://www.hangge.com/blog_uploads/202005/2020050815390656086.jpg" alt="原文:将本地库批量导入到Nexus3.x上（Maven私服）"></a></p>
<p>（2）选择 <strong>maven2(hosted)</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.hangge.com/blog/cache/detail_2910.html#"><img src="https://www.hangge.com/blog_uploads/202005/2020050815461035865.jpg" alt="原文:将本地库批量导入到Nexus3.x上（Maven私服）"></a></p>
<p>（3）按照自身需求填写如下选项（仓库名随意）：</p>
<p><a target="_blank" rel="noopener" href="https://www.hangge.com/blog/cache/detail_2910.html#"><img src="https://www.hangge.com/blog_uploads/202005/2020050816011744772.jpg" alt="原文:将本地库批量导入到Nexus3.x上（Maven私服）"></a></p>
<p>（4）在服务器 <strong>/home</strong> 目录下，新建一个文件夹 <strong>repo</strong>，批量放入我们需要的本地库文件夹：</p>
<p><a target="_blank" rel="noopener" href="https://www.hangge.com/blog/cache/detail_2910.html#"><img src="https://www.hangge.com/blog_uploads/202005/2020050816145426949.png" alt="原文:将本地库批量导入到Nexus3.x上（Maven私服）"></a></p>
<p>（5）在 <strong>repo</strong> 文件夹下执行如下命令创建一个 <strong>shell</strong> 脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi mavenimport.sh</span><br></pre></td></tr></table></figure>


<p>（6）脚本内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># copy and run this script to the root of the repository directory containing files</span><br><span class="line"># this script attempts to exclude uploading itself explicitly so the script name is important</span><br><span class="line"># Get command line params</span><br><span class="line">while getopts &quot;:r:u:p:&quot; opt; do</span><br><span class="line">    case $opt in</span><br><span class="line">        r) REPO_URL=&quot;$OPTARG&quot;</span><br><span class="line">        ;;</span><br><span class="line">        u) USERNAME=&quot;$OPTARG&quot;</span><br><span class="line">        ;;</span><br><span class="line">        p) PASSWORD=&quot;$OPTARG&quot;</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br><span class="line">  </span><br><span class="line">find . -type f -not -path &#x27;./mavenimport\.sh*&#x27; -not -path &#x27;*/\.*&#x27; -not -path &#x27;*/\^archetype\-catalog\.xml*&#x27; -not -path &#x27;*/\^maven\-metadata\-local*\.xml&#x27; -not -path &#x27;*/\^maven\-metadata\-deployment*\.xml&#x27; | sed &quot;s|^\./||&quot; | xargs -I &#x27;&#123;&#125;&#x27; curl -u &quot;$USERNAME:$PASSWORD&quot; -X PUT -v -T &#123;&#125; $&#123;REPO_URL&#125;/&#123;&#125; ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>（7）保存退出后执行如下命令赋予其执行权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod` `+x mavenimport.sh</span><br></pre></td></tr></table></figure>


<p>（8）执行如下命令即可将该目录下的 <strong>jar</strong> 包都导入到指定仓库中：</p>
<p><strong>注意：</strong>命令中 <strong>Nexus</strong> 用户名、用户密码、仓库地址根据实际情况进行修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mavenimport.sh -u admin -p 123 -r http:``//192.168.60.133:8081/repository/my_repo/</span><br></pre></td></tr></table></figure>


<p>（9）访问 <strong>Nexus</strong> 控制台页面，可以发现确实都上传成功了：</p>
<p><a target="_blank" rel="noopener" href="https://www.hangge.com/blog/cache/detail_2910.html#"><img src="https://www.hangge.com/blog_uploads/202005/2020050816335416351.png" alt="原文:将本地库批量导入到Nexus3.x上（Maven私服）"></a></p>
<p>-————————-</p>
<p><strong>打完收工</strong></p>
<p>*************** 当你发现自己的才华撑不起野心时，就请安静下来学习吧！***************</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/09/Maven%E7%A7%81%E6%9C%8DNexus3/" data-id="clh04c6de0006o4rg6fxl07k8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jenkins+gitlab+docker+maven多模块" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/09/jenkins+gitlab+docker+maven%E5%A4%9A%E6%A8%A1%E5%9D%97/" class="article-date">
  <time datetime="2021-01-09T05:38:42.484Z" itemprop="datePublished">2021-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="jenkins-gitlab-docker-maven多模块"><a href="#jenkins-gitlab-docker-maven多模块" class="headerlink" title="jenkins+gitlab+docker+maven多模块"></a>jenkins+gitlab+docker+maven多模块</h1><h3 id="1-关于jenkins使用过程中的一些心得"><a href="#1-关于jenkins使用过程中的一些心得" class="headerlink" title="1. 关于jenkins使用过程中的一些心得"></a>1. 关于jenkins使用过程中的一些心得</h3><ul>
<li><p>jenkins的很多功能都是依赖于插件实现的，找不到某项功能的时候先查看是不是没有安装相应的插件</p>
</li>
<li><p>jenkins支持模块，会根据父pom找到里面的模块，会多出一个模块按钮</p>
<p><img src="C:\Users\Hasee\AppData\Roaming\Typora\typora-user-images\image-20210109210338250.png" alt="image-20210109210338250"></p>
</li>
</ul>
<p>点进去可以打包或者编译，但是没有其他的相关操作，最终的其他处理还需要在顶层配置</p>
<ul>
<li>maven的选项配置是个好东西</li>
</ul>
<h3 id="2-测试环境的配置"><a href="#2-测试环境的配置" class="headerlink" title="2. 测试环境的配置"></a>2. 测试环境的配置</h3><p><img src="C:\Users\Hasee\AppData\Roaming\Typora\typora-user-images\image-20210109210958497.png" alt="image-20210109210958497"></p>
<p><img src="C:\Users\Hasee\AppData\Roaming\Typora\typora-user-images\image-20210109211104045.png" alt="image-20210109211104045"></p>
<p><img src="C:\Users\Hasee\AppData\Roaming\Typora\typora-user-images\image-20210109211122175.png" alt="image-20210109211122175"></p>
<p><img src="C:\Users\Hasee\AppData\Roaming\Typora\typora-user-images\image-20210109211138406.png" alt="image-20210109211138406"></p>
<p><img src="C:\Users\Hasee\AppData\Roaming\Typora\typora-user-images\image-20210109211152851.png" alt="image-20210109211152851"></p>
<p><strong>最关键的地方</strong>,root pom :代表父工程pom文件，Goals and options:配置,要发布哪个子模块，pl后面就写那个子模块 ，pl意思是把相关配置项目一起打成jar包。<br><img src="https://img-blog.csdnimg.cn/20201112143904999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAzMTgx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3-流水线关键脚本"><a href="#3-流水线关键脚本" class="headerlink" title="3. 流水线关键脚本"></a>3. 流水线关键脚本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123;</span><br><span class="line">        registryUrl= &quot;172.17.66.165:8009&quot; //搭建docker私有仓库（Harbor/nexus）或者 用DockerHub 又或者用云平台的“容器镜像服务”</span><br><span class="line">        registry_user= &quot;grid&quot;</span><br><span class="line">        registry_pass= &quot;grid@123&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    options &#123;</span><br><span class="line">        timestamps()  //设置在项目打印日志时带上对应时间</span><br><span class="line">        disableConcurrentBuilds()  //不允许同时执行流水线，被用来防止同时访问共享资源等</span><br><span class="line">        timeout(time: 5, unit: &#x27;MINUTES&#x27;)  // 设置流水线运行超过n分钟，Jenkins将中止流水线</span><br><span class="line">        buildDiscarder(logRotator(numToKeepStr: &#x27;10&#x27;))   // 表示保留n次构建历史</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //gitlab  webhook触发器</span><br><span class="line">    //代码推到gitlab上后，所有子项目将被触发构建，不可取，待优化启用</span><br><span class="line">    //triggers&#123;</span><br><span class="line">    //   gitlab( triggerOnPush: true,                       //代码有push动作就会触发job</span><br><span class="line">    //       triggerOnMergeRequest: true,                   //代码有merge动作就会触发job</span><br><span class="line">    //        branchFilterType: &quot;NameBasedFilter&quot;,          //只有符合条件的分支才会触发构建 “All/NameBasedFilter/RegexBasedFilter”</span><br><span class="line">    //        includeBranchesSpec: &quot;$&#123;Branch_name&#125;&quot;)      //基于branchFilterType值，输入期望包括的分支的规则</span><br><span class="line">    //&#125;</span><br><span class="line"></span><br><span class="line">    stages&#123;</span><br><span class="line">        stage(&#x27;Print Message&#x27;) &#123;   //打印信息</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &#x27;打印信息&#x27;</span><br><span class="line">                echo &quot;Project_Pipeline_name: $&#123;JOB_NAME&#125;&quot;</span><br><span class="line">                echo &quot;Project_module_name: $&#123;PROJECT_NAME&#125;&quot;</span><br><span class="line">                echo &quot;workspace: $&#123;WORKSPACE&#125;&quot;</span><br><span class="line">                echo &quot;branch: $&#123;Branch_name&#125;&quot;    //gitlab分支名</span><br><span class="line">                echo &quot;build_id: $&#123;BUILD_ID&#125;&quot;</span><br><span class="line">                echo &quot;target_action: $&#123;action&#125;&quot;</span><br><span class="line">                echo &quot;registryUrl: $&#123;registryUrl&#125;&quot;</span><br><span class="line">                echo &quot;image_repository: $&#123;registryUrl&#125;/$&#123;Project_name&#125;&quot;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage (&#x27;Checkout&#x27;)&#123;   //拉取代码</span><br><span class="line">            steps&#123;</span><br><span class="line">                echo &#x27;拉取代码&#x27;</span><br><span class="line">                script &#123;</span><br><span class="line">                    if ( action == &#x27;deploy&#x27; ) &#123;    //判断当action == &#x27;deploy&#x27; 时，才执行此stage</span><br><span class="line">                        checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;$&#123;Branch_name&#125;&#x27;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [],</span><br><span class="line">                            userRemoteConfigs: [[credentialsId: &#x27;40ba7c18-dd55-4d21-9853-af38b353671c&#x27;, //gitlab登录令牌，如何设置自行搜索方法</span><br><span class="line">                            url: &#x27;http://172.17.66.164:8098/grid/grid-boot.git&#x27;]]])    //gitlab项目clone地址</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;Packaging project&#x27;) &#123;        //mvn打包</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &#x27;mvn打包子项目&#x27;</span><br><span class="line">                script &#123;</span><br><span class="line">                    if ( action == &#x27;deploy&#x27; ) &#123;</span><br><span class="line">                        try &#123;    //此步骤执行失败，将终止流水线工作</span><br><span class="line">                            sh &#x27;source /etc/profile &amp;&amp; mvn clean install -pl $&#123;Project_name&#125; -am -amd -P$&#123;Profiles_name&#125; -Dmaven.test.skip=true&#x27;</span><br><span class="line">                            //“-pl”指定子项目名称 ； “-P”指定使用哪个环节的配置文件（-Ptest即表示使用文件application-test.yml配置文件打包）</span><br><span class="line">                        &#125; catch (err) &#123;</span><br><span class="line">                            echo &#x27;Packaging project failed &amp; End of Pipeline!!!&#x27;</span><br><span class="line">                            //echo &#x27;可能原因：（1）上一次失败构建或中断构建项目后，工作目录$&#123;WORKSPACE&#125;没有清理（可选择手动执行rm -rf $&#123;WORKSPACE&#125;/*）&#x27;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		stage(&#x27;Sonar-canner&#x27;) &#123;   //sonar-scanner代码检查</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &#x27;代码检查&#x27;</span><br><span class="line">                dir (&#x27;./&#x27;) &#123;       //指定工作目录（默认为$&#123;WORKSPACE&#125;）</span><br><span class="line">                   script &#123;</span><br><span class="line">				     try &#123; </span><br><span class="line">					   if ( action == &#x27;deploy&#x27; ) &#123;</span><br><span class="line">                        sh &#x27;sonar-scanner&#x27;  //执行命令开始扫描代码(前提要maven编译生成classes文件)</span><br><span class="line">                       &#125;</span><br><span class="line">					 &#125; catch (err) &#123;</span><br><span class="line">					     echo &#x27;Packaging project failed &amp; End of Pipeline!!!&#x27;</span><br><span class="line">                         echo echo &#x27;可能原因：（1）mvn打包子项目失败；（2）上一次失败构建或中断构建项目后，工作目录$&#123;WORKSPACE&#125;没有清理（手动执行rm -rf $&#123;WORKSPACE&#125;/*）&#x27;</span><br><span class="line">					 &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">	   &#125;</span><br><span class="line">        stage(&#x27;Build &amp; Push Image to Harbor/nexus&#x27;) &#123;      //构建，推送镜像</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &#x27;构建，推送镜像到docker镜像仓库&#x27;</span><br><span class="line">                dir (&#x27;./&#x27;) &#123;       //指定工作目录（默认为$&#123;WORKSPACE&#125;）</span><br><span class="line">                    script &#123;</span><br><span class="line">                        if ( action == &#x27;deploy&#x27; ) &#123;</span><br><span class="line">                            try &#123;                               </span><br><span class="line">                                //方法一：</span><br><span class="line">                                sh &#x27;docker login  --username=$&#123;registry_user&#125; --password=$&#123;registry_pass&#125;   $&#123;registryUrl&#125;&#x27;</span><br><span class="line">                                sh &#x27;cp $&#123;Project_name&#125;/target/*.jar ./&#x27;</span><br><span class="line">                                sh &#x27;docker build  -t $&#123;registryUrl&#125;/$&#123;Project_name&#125;:$&#123;Profiles_name&#125;-$&#123;BUILD_ID&#125; -f ./Dockerfile_config/$&#123;Project_name&#125;/Dockerfile . &#x27;</span><br><span class="line">                                sh &#x27;docker push $&#123;registryUrl&#125;/$&#123;Project_name&#125;:$&#123;Profiles_name&#125;-$&#123;BUILD_ID&#125;&#x27;</span><br><span class="line">                                //方法二：</span><br><span class="line">                                //sh &#x27;docker login  --username=$&#123;registry_user&#125; --password=$&#123;registry_pass&#125;   $&#123;registryUrl&#125;&#x27;</span><br><span class="line">                                //sh &#x27;cp $&#123;Project_name&#125;/target/*.jar ./ &#x27;</span><br><span class="line">                                //def app = docker.build(&#x27;$&#123;registryUrl&#125;/$&#123;Project_name&#125;:$&#123;Profiles_name&#125;-$&#123;BUILD_ID&#125; -f ./Dockerfile_config/$&#123;Project_name&#125;/Dockerfile&#x27;)</span><br><span class="line">                                //app.push(&#x27;$&#123;Profiles_name&#125;-$&#123;BUILD_ID&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">                                //sh &#x27;docker rmi $&#123;registryUrl&#125;/$&#123;Project_name&#125;:$&#123;Profiles_name&#125;-$&#123;BUILD_ID&#125;&#x27;</span><br><span class="line">                            &#125; catch (err) &#123;</span><br><span class="line">                                echo &#x27;Build Image failed &amp; End of Pipeline!!!&#x27;</span><br><span class="line">                                echo &#x27;可能原因：（1）mvn打包子项目失败；（2）上一次失败构建或中断构建项目后，工作目录$&#123;WORKSPACE&#125;没有清理（手动执行rm -rf $&#123;WORKSPACE&#125;/*）&#x27;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;Deploy to the Target server&#x27;) &#123;      //部署到目标服务器</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &#x27;部署到目标服务器&#x27;</span><br><span class="line">                script &#123;</span><br><span class="line">                    timeout(time: 60, unit: &#x27;SECONDS&#x27;) &#123;    // 设置远程部署超过n秒，将终止该步骤</span><br><span class="line">                        sh &#x27;bash  ./Deploy.sh  $&#123;Project_name&#125;  $&#123;registryUrl&#125;/$&#123;Project_name&#125;:$&#123;Profiles_name&#125;  $&#123;Profiles_name&#125;  $&#123;action&#125;  $&#123;BUILD_ID&#125; $&#123;rollback_id&#125;&#x27;   //$&#123;1,2,3,4,5,6&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		&#125;</span><br><span class="line">        //此步骤在调试Jenkinsfile时可以注释以便了解目录结构</span><br><span class="line">        //亦可以忽略这步骤（有磁盘空间，任性）</span><br><span class="line">        // stage(&#x27;Delete Workspace&#x27;) &#123;         //清理工作目录（从jenkins上清除刚拉取的代码及mvn编译打包的内容，节省磁盘空间）</span><br><span class="line">        //     steps &#123;</span><br><span class="line">        //         echo &quot;清理工作目录: $&#123;WORKSPACE&#125;&quot;</span><br><span class="line">        //         deleteDir()     //表示删除当前目录($&#123;WORKSPACE&#125;)下内容，通常用在构建完毕之后清空工作空间</span><br><span class="line">        //     &#125;</span><br><span class="line">        // &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/09/jenkins+gitlab+docker+maven%E5%A4%9A%E6%A8%A1%E5%9D%97/" data-id="clh04c6do000ho4rg8zv6hqq5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/18/%E5%A4%8D%E4%B9%A0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/23/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/11/Spring%20Security%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E7%9A%84%E5%8E%9F%E7%90%86/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/02/16/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%20%EF%BC%88jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/01/06/Docker%20Volume/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>