<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Spring Security认证与授权的原理一、概念：Spring Security所解决的问题就是安全访问控制，而安全访问控制功能其实就是所有进入系统的请求进行拦截，校验每一个请求是否能够访问它所期望的资源，可以通过Filter或AOP等技术来实现，Spring Security对web资源的保护是靠Filter来实现的。 当初始化Spring Security时，会创建一个名为SpringS">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2022/03/11/Spring%20Security%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E7%9A%84%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Spring Security认证与授权的原理一、概念：Spring Security所解决的问题就是安全访问控制，而安全访问控制功能其实就是所有进入系统的请求进行拦截，校验每一个请求是否能够访问它所期望的资源，可以通过Filter或AOP等技术来实现，Spring Security对web资源的保护是靠Filter来实现的。 当初始化Spring Security时，会创建一个名为SpringS">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200503191744839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200514222157974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200503192522763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200503193813635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020051423151314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200514232459603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200514233644210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200503214152166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200515195318922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200515195732146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200515195959248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200515201311361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200515201431315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200515200038401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200515200254950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200515201531678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2022-03-11T07:14:19.712Z">
<meta property="article:modified_time" content="2022-03-11T07:49:33.857Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200503191744839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Spring Security认证与授权的原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/11/Spring%20Security%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E7%9A%84%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2022-03-11T07:14:19.712Z" itemprop="datePublished">2022-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spring-Security认证与授权的原理"><a href="#Spring-Security认证与授权的原理" class="headerlink" title="Spring Security认证与授权的原理"></a>Spring Security认证与授权的原理</h1><h3 id="一、概念："><a href="#一、概念：" class="headerlink" title="一、概念："></a>一、概念：</h3><p>Spring Security所解决的问题就是安全访问控制，而安全访问控制功能其实就是所有进入系统的请求进行拦截，校验每一个请求是否能够访问它所期望的资源，可以通过Filter或AOP等技术来实现，Spring Security对web资源的保护是靠Filter来实现的。</p>
<p>当初始化Spring Security时，会创建一个名为SpringSecurityFilterChain的servlet过滤器，类型是org.springframework.security.web.FilterChainProxy（有doFilter方法），它实现了javax.servlet.Filter，因此外部请求的类都会经过此类。如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200503191744839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>实际上，看源代码我们知道FilterChainProxy是一个代理，真正起作用的是FilterChainProxy中SecurityFilterChain所包含的各个Filter，同时 这些Filter作为Bean被Spring管理，它们是Spring Security核心，各有各的职责，但他们并不直接处理用户的认证，也不直接处理用户的授权，而是把它们交给了认证管理器（AuthenticationManager）和决策管理器（AccessDecisionManager）进行处理，下图是FilterChainProxy相关类的UML图示（直接网上找图）。</p>
<p><img src="https://img-blog.csdnimg.cn/20200514222157974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>不知道UML图的小伙伴们，可以去学一波这个姿势。</p>
<p>Spring Security功能的实现主要是由一系列过滤器链相互配合完成。</p>
<p><img src="https://img-blog.csdnimg.cn/20200503192522763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>（1）SecurityContextPersistenceFilter：这个Filter是整个拦截过程的入口和出口(也就是第一个和最后- 一个拦截器) , 会在请求开始时从配置好的SecurityContextRepository中获取SecurityContext ,然后把它设置给SecurityContextHolder.在请求完成后将SecurityContextHolder持有的SecurityContext再保存到配置好的SecurityContextRepository ,同时清除securityContextHolder所持有的SecurityContext ; .</p>
<p>（2）UsernamePasswordAuthenticationFilter：用于处理来自表单提交的认证。该表单必须提供对应的用户名和密码,其内部还有登录成功或失败后进行处理的AuthenticationSuccessHandler和AuthenticationFailureHandler ,这些都可以根据需求做相关改变;</p>
<p>（3）FilteSecurityInterceptor：是用于保护web资源的,使用AccessDecisionManager对当前用户进行授权访问,前面已经详细介绍过了;</p>
<p>（4）ExceptionTranslationFilter：ExceptionTranslationFilter能够捕获来自FilterChain 所有的异常,并进行处理。但是它只会处理两类异常:ExceptionTranslationFilter能够捕获来自FilterChain 所有的异常,并进行处理。但是它只会处理两类异常:<br>AuthenticationException和AccessDeniedException ,其它的异常它会继续抛出。</p>
<h3 id="二、认证流程："><a href="#二、认证流程：" class="headerlink" title="二、认证流程："></a>二、认证流程：</h3><p><img src="https://img-blog.csdnimg.cn/20200503193813635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>（1）用户提交用户名和密码被UsernamePasswordAuthenticationFilter获取到，然后请求的信息被封装为Authentication的实现类UsernamePasswordAuthenticationToken对象。我们来看一下这个源码：UsernamePasswordAuthenticationFilter类的attemptAuthentication方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class UsernamePasswordAuthenticationFilter extends</span><br><span class="line">		AbstractAuthenticationProcessingFilter &#123;</span><br><span class="line">	</span><br><span class="line">	public static final String SPRING_SECURITY_FORM_USERNAME_KEY = &quot;username&quot;;</span><br><span class="line">	public static final String SPRING_SECURITY_FORM_PASSWORD_KEY = &quot;password&quot;;</span><br><span class="line"> </span><br><span class="line">	private String usernameParameter = SPRING_SECURITY_FORM_USERNAME_KEY;</span><br><span class="line">	private String passwordParameter = SPRING_SECURITY_FORM_PASSWORD_KEY;</span><br><span class="line">	private boolean postOnly = true;</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">	public UsernamePasswordAuthenticationFilter() &#123;</span><br><span class="line">		super(new AntPathRequestMatcher(&quot;/login&quot;, &quot;POST&quot;));</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	//设置Authentication</span><br><span class="line">	public Authentication attemptAuthentication(HttpServletRequest request,</span><br><span class="line">			HttpServletResponse response) throws AuthenticationException &#123;</span><br><span class="line">		if (postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) &#123;</span><br><span class="line">			throw new AuthenticationServiceException(</span><br><span class="line">					&quot;Authentication method not supported: &quot; + request.getMethod());</span><br><span class="line">		&#125;</span><br><span class="line">        //获取参数</span><br><span class="line">		String username = obtainUsername(request);</span><br><span class="line">		String password = obtainPassword(request);</span><br><span class="line"> </span><br><span class="line">		if (username == null) &#123;</span><br><span class="line">			username = &quot;&quot;;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		if (password == null) &#123;</span><br><span class="line">			password = &quot;&quot;;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		username = username.trim();</span><br><span class="line">        //创建Authentication</span><br><span class="line">		UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(</span><br><span class="line">				username, password);</span><br><span class="line"> </span><br><span class="line">		//设置主机地址和sessionId</span><br><span class="line">		setDetails(request, authRequest);</span><br><span class="line">        //通过这个方法去找到AuthenticationManager认证。</span><br><span class="line">		return this.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">	@Nullable</span><br><span class="line">	protected String obtainPassword(HttpServletRequest request) &#123;</span><br><span class="line">		return request.getParameter(passwordParameter);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">	@Nullable</span><br><span class="line">	protected String obtainUsername(HttpServletRequest request) &#123;</span><br><span class="line">		return request.getParameter(usernameParameter);</span><br><span class="line">	&#125;</span><br><span class="line">	//设置主机地址和sessionId</span><br><span class="line">	protected void setDetails(HttpServletRequest request,</span><br><span class="line">			UsernamePasswordAuthenticationToken authRequest) &#123;</span><br><span class="line">		authRequest.setDetails(authenticationDetailsSource.buildDetails(request));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（2）将Authentication（也就是上面的authRequest）交给AuthenticationManager去认证。之后我们就到了AuthenticationManager的子类ProviderManager这个类。经过辗转到DaoAuthenticationProvider的retrieveUser方法。通过loadUserByUsername找到对应的用户信息，实际上就是通过UserDetailService来办到的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected final UserDetails retrieveUser(String username,</span><br><span class="line">			UsernamePasswordAuthenticationToken authentication)</span><br><span class="line">			throws AuthenticationException &#123;</span><br><span class="line">		prepareTimingAttackProtection();</span><br><span class="line">		try &#123;</span><br><span class="line">//查询对应的用户信息</span><br><span class="line">			UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">			if (loadedUser == null) &#123;</span><br><span class="line">				throw new InternalAuthenticationServiceException(</span><br><span class="line">						&quot;UserDetailsService returned null, which is an interface contract violation&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">//返回</span><br><span class="line">			return loadedUser;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (UsernameNotFoundException ex) &#123;</span><br><span class="line">			mitigateAgainstTimingAttack(authentication);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (InternalAuthenticationServiceException ex) &#123;</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Exception ex) &#123;</span><br><span class="line">			throw new InternalAuthenticationServiceException(ex.getMessage(), ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/2020051423151314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>（3）核对认证：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected void additionalAuthenticationChecks(UserDetails userDetails,</span><br><span class="line">			UsernamePasswordAuthenticationToken authentication)</span><br><span class="line">			throws AuthenticationException &#123;</span><br><span class="line">//如果用户没输入密码，直接抛出异常！</span><br><span class="line">		if (authentication.getCredentials() == null) &#123;</span><br><span class="line">			logger.debug(&quot;Authentication failed: no credentials provided&quot;);</span><br><span class="line"> </span><br><span class="line">			throw new BadCredentialsException(messages.getMessage(</span><br><span class="line">					&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;,</span><br><span class="line">					&quot;Bad credentials&quot;));</span><br><span class="line">		&#125;</span><br><span class="line">//获取用户的密码</span><br><span class="line">		String presentedPassword = authentication.getCredentials().toString();</span><br><span class="line">//用编码器去匹配</span><br><span class="line">		if (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line">			logger.debug(&quot;Authentication failed: password does not match stored value&quot;);</span><br><span class="line"> </span><br><span class="line">			throw new BadCredentialsException(messages.getMessage(</span><br><span class="line">					&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;,</span><br><span class="line">					&quot;Bad credentials&quot;));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>只要不抛出异常就是正确了。</p>
<p>（4）重新封装Authentication返回UsernamePasswordAuthenticationFilter。</p>
<p><img src="https://img-blog.csdnimg.cn/20200514232459603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>（5）封装到上下文（AbstractAuthenticationProcessingFilter）：</p>
<p><img src="https://img-blog.csdnimg.cn/20200514233644210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>我们再来看一下这里涉及的类：</p>
<p>（1）AuthenticationProvider ： AuthenticationManager委托这个接口的实现类来处理认证。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface AuthenticationProvider &#123; </span><br><span class="line">    Authentication authenticate(Authentication authentication) throws         </span><br><span class="line">    AuthenticationException; boolean supports(Class&lt;?&gt; var1); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>authenticate () 方法定义了 认证的实现过程 ，它的参数是一个 Authentication ，里面包含了登录用户所提交的用<br>户、密码等。而返回值也是一个 Authentication ，这个 Authentication 则是在认证成功后，将用户的权限及其他信<br>息重新组装后生成。</p>
<p>Spring Security 中维护着一个 List<AuthenticationProvider> 列表，存放多种认证方式，不同的认证方式使用不<br>同的 AuthenticationProvider 。如使用用户名密码登录时，使用 AuthenticationProvider1 ，短信登录时使用<br>AuthenticationProvider2。</p>
<p>每个 AuthenticationProvider 需要实现 supports （） 方法来表明自己支持的认证方式，如我们使用表单方式认证，<br>在提交请求时 Spring Security 会生成 UsernamePasswordAuthenticationToken ，它是一个 Authentication ，里面<br>封装着用户提交的用户名、密码信息。而对应的，哪个 AuthenticationProvider 来处理它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//DaoAuthenticationProvider的基类AbstractUserDetailsAuthenticationProvider</span><br><span class="line">public boolean supports(Class&lt;?&gt; authentication) &#123; </span><br><span class="line">    return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>也就是说当 web 表单提交用户名密码时， Spring Security 由 DaoAuthenticationProvider 处理。</p>
<p>（1）Authentication： 认证信息结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface Authentication extends Principal, Serializable &#123;</span><br><span class="line">    //权限信息  </span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); </span><br><span class="line">    //密码</span><br><span class="line">    Object getCredentials(); </span><br><span class="line">    //细节信息:ip，sessionId</span><br><span class="line">    Object getDetails(); </span><br><span class="line">    //账号</span><br><span class="line">    Object getPrincipal(); </span><br><span class="line">    boolean isAuthenticated(); void setAuthenticated(boolean var1) throws IllegalArgumentException; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面给大家debug的时候，不知道大家发现没有，principal这个字段在封装请求信息的时候是username，但是在认证通过后返回信息的时候就封装住了账号、密码以及权限等信息。</p>
<p>（3）UserDetailsService：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDetailsService &#123; </span><br><span class="line">    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的作用就是从数据库或者内存中查询出账号密码，封装成UserDetails，然后返回给我们DaoAuthenticationProvider，进行认证。我们可以实现一个类去继承这个Service，然后从数据库中查询出信息。之前在上篇文章中是用的内存的方式@Bean注入到IOC中了。</p>
<p>（4）UserDetails</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDetails extends Serializable &#123; </span><br><span class="line">//权限</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); </span><br><span class="line">//用户名</span><br><span class="line">    String getPassword(); </span><br><span class="line">//密码</span><br><span class="line">    String getUsername(); </span><br><span class="line">//</span><br><span class="line">    boolean isAccountNonExpired(); </span><br><span class="line">    boolean isAccountNonLocked(); </span><br><span class="line">    boolean isCredentialsNonExpired(); </span><br><span class="line">    boolean isEnabled(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们来扩展一下UserDetailService，从数据库中查询出信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class SpringDataUserDetailService implements UserDetailsService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private IUserService userService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PermissionMapper permissionMapper;</span><br><span class="line">     </span><br><span class="line">    @Override</span><br><span class="line">    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123;</span><br><span class="line">        //查询用户信息</span><br><span class="line">        UserAdmin userAmin = userService.selectUserByUsername(s);</span><br><span class="line">        log.info(&quot;user =&gt; &#123;&#125;&quot;,userAmin);</span><br><span class="line">        if(userAmin == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //查询权限</span><br><span class="line">        List&lt;String&gt; list =  permissionMapper.selectPermissionByUser(userAmin.getId());</span><br><span class="line">        String[] arr = new String[list.size()];</span><br><span class="line">        list.toArray(arr);</span><br><span class="line">        UserDetails user = User.withUsername(userAmin.getUsername()).password(userAmin.getPassword()).authorities(arr).build();</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询对应的用户信息和权限！！！</p>
<p>（4）PasswordEncoder：</p>
<p>DaoAuthenticationProvider 认证处理器通过 UserDetailsService 获取到 UserDetails 后，它是如何与请求 Authentication中的密码做对比呢？ 在这里Spring Security 为了适应多种多样的加密类型，又做了抽象， DaoAuthenticationProvider 通过 PasswordEncoder接口的 matches 方法进行密码的对比，而具体的密码对比细节取决于实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface PasswordEncoder &#123; </span><br><span class="line">    String encode(CharSequence var1); </span><br><span class="line">    boolean matches(CharSequence var1, String var2); </span><br><span class="line">    default boolean upgradeEncoding(String encodedPassword) &#123; return false; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 Spring Security 提供很多内置的 PasswordEncoder ，能够开箱即用，使用某种 PasswordEncoder 只需要进行如<br>下声明即可，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean </span><br><span class="line">public PasswordEncoder passwordEncoder() &#123; </span><br><span class="line">    return NoOpPasswordEncoder.getInstance(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NoOpPasswordEncoder 采用字符串匹配方法，不对密码进行加密比较处理，密码比较流程如下：</p>
<p>（1）用户输入密码（明文 ）<br>（2）DaoAuthenticationProvider 获取 UserDetails （其中存储了用户的正确密码）<br>（3）DaoAuthenticationProvider 使用 PasswordEncoder 对输入的密码和正确的密码进行校验，密码一致则校验通<br>过，否则校验失败。 NoOpPasswordEncoder 的校验规则拿 输入的密码和 UserDetails 中的正确密码进行字符串比较，字符串内容一致 则校验通过，否则 校验失败。</p>
<p>三、授权流程：<br>Spring Security 可以通过 http.authorizeRequests() 对 web 请求进行授权保护。 Spring Security使用标准 Filter 建立了对 web 请求的拦截，最终实现对资源的授权访问。</p>
<p><img src="https://img-blog.csdnimg.cn/20200503214152166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>分析授权流程：<br>（1） 拦截请求： 已认证用户访问受保护的 web 资源将被 SecurityFilterChain 中的 FilterSecurityInterceptor 的子 类拦截。</p>
<p> <img src="https://img-blog.csdnimg.cn/20200515195318922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200515195732146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>这里面1就是授权的具体步骤，2是如果授权通过执行的真正的业务，3是后续处理。</p>
<p>（2）获取资源访问策略：FilterSecurityInterceptor 会从 SecurityMetadataSource 的子类<br>DefaultFilterInvocationSecurityMetadataSource 获取要访问当前资源所需要的权限 Collection<ConfigAttribute>。 SecurityMetadataSource 其实就是读取访问策略的抽象，而读取的内容，其实就是我们配置的访问规则， 读<br>取访问策略如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">       http.csrf().disable()</span><br><span class="line">               .authorizeRequests()</span><br><span class="line">               .antMatchers(&quot;/r/r1&quot;).hasAuthority(&quot;r1&quot;)</span><br><span class="line">               .antMatchers(&quot;/r/r2&quot;).hasAuthority(&quot;r2&quot;)</span><br><span class="line">               ....</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>进入AbstractSecurityInterceptor的beforeInvocation方法，获取对应的需要的权限：</p>
<p><img src="https://img-blog.csdnimg.cn/20200515195959248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200515201311361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200515201431315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>p1和p2是用户现在拥有的权限。r1是要求的权限</p>
<p>（3）授权决策：FilterSecurityInterceptor 会调用 AccessDecisionManager 进行授权决策，若决策通过，则允许访问资<br>源，否则将禁止访问。</p>
<p><img src="https://img-blog.csdnimg.cn/20200515200038401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>稍后我们会具体的介绍都有哪些决策方式，这里我们以默认的为例AffirmativeBased是AccessDecisionManager子类</p>
<p><img src="https://img-blog.csdnimg.cn/20200515200254950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200515201531678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4ODQ5NQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>result就是决策投票的结果，如果是1代表赞成、-1代表反对、0代表弃权。如果通过，那么用户就可以访问到对应的资源。</p>
<p>三种授权决策 ：<br>AccessDecisionManager 采用 投票 的方式来确定是否能够访问受保护资源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface AccessDecisionVoter&lt;S&gt; &#123; </span><br><span class="line">    int ACCESS_GRANTED = 1; </span><br><span class="line">    int ACCESS_ABSTAIN = 0; </span><br><span class="line">    int ACCESS_DENIED = ‐1; </span><br><span class="line">    boolean supports(ConfigAttribute var1);     </span><br><span class="line">    boolean supports(Class&lt;?&gt; var1); </span><br><span class="line">    int vote(Authentication var1, S var2, Collection&lt;ConfigAttribute&gt; var3); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vote() 方法的返回结果会是 AccessDecisionVoter 中定义的三个常量之一。 ACCESS_GRANTED 表示同意， ACCESS_DENIED表示拒绝， ACCESS_ABSTAIN 表示弃权。如果一个 AccessDecisionVoter 不能判定当前 Authentication是否拥有访问对应受保护对象的权限，则其 vote() 方法的返回值应当为弃权 ACCESS_ABSTAIN 。</p>
<p>三个实现类：</p>
<p>1、AffiffiffirmativeBased：</p>
<p>（1）只要有AccessDecisionVoter的投票为ACCESS_GRANTED则同意用户进行访问；</p>
<p>（2）如果全部弃权也表示通过；</p>
<p>（3）如果没有一个人投赞成票，但是有人投反对票，则将抛出AccessDeniedException。</p>
<p>2、 ConsensusBased：<br>（1）如果赞成票多于反对票则表示通过。</p>
<p>（2）反过来，如果反对票多于赞成票则将抛出AccessDeniedException。</p>
<p>（3）如果赞成票与反对票相同且不等于0，并且属性allowIfEqualGrantedDeniedDecisions的值为true，则表 示通过，否则将抛出异常AccessDeniedException。参数allowIfEqualGrantedDeniedDecisions的值默认为true。</p>
<p>（4）如果所有的AccessDecisionVoter都弃权了，则将视参数allowIfAllAbstainDecisions的值而定，如果该值 为true则表示通过，否则将抛出异常AccessDeniedException。参数allowIfAllAbstainDecisions的值默认为false。</p>
<p>3、 UnanimousBased<br>逻辑与另外两种实现有点不一样，另外两种会一次性把受保护对象的配置属性全部传递 给AccessDecisionVoter进行投票，而UnanimousBased会一次只传递一个ConfifigAttribute给 AccessDecisionVoter进行投票。这也就意味着如果我们的AccessDecisionVoter的逻辑是只要传递进来的 ConfifigAttribute中有一个能够匹配则投赞成票，但是放到UnanimousBased中其投票结果就不一定是赞成了。 UnanimousBased的逻辑具体来说是这样的：</p>
<p>（1）如果受保护对象配置的某一个ConfifigAttribute被任意的AccessDecisionVoter反对了，则将抛出<br>AccessDeniedException。</p>
<p>（2）如果没有反对票，但是有赞成票，则表示通过。</p>
<p>（3）如果全部弃权了，则将视参数allowIfAllAbstainDecisions的值而定，true则通过，false则抛出<br>AccessDeniedException</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/11/Spring%20Security%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E7%9A%84%E5%8E%9F%E7%90%86/" data-id="clh04c6dg0007o4rg1ga0bmjf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/03/23/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2022/02/16/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%20%EF%BC%88jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/18/%E5%A4%8D%E4%B9%A0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/23/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/11/Spring%20Security%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E7%9A%84%E5%8E%9F%E7%90%86/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/02/16/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%20%EF%BC%88jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/01/06/Docker%20Volume/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>